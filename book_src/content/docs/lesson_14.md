---
title: "Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам"
type: docs
slug: "lesson_14"
BookToC: 3
---

## Введение

Сегодня мы научимся раскидывать хэндлеры по разным файлам, чтобы не плодить огромные портянки кода, а также познакомимся с механизмом FSM (Finite State Machine, конечный автомат состояний), но уже в библиотеке aiogram. 

{{< expand "Примечание" >}}
Если по какой-то причине вы всё ещё используете pyTelegramBotAPI, то информация о FSM для него доступна в [уроке 11]({{< relref "/docs/lesson_11" >}}).  
Все исходные коды к этому уроку актуальны для aiogram версии 2.x. В будущем, когда выйдет третья версия фреймворка, этот урок может быть неактуален.
{{< /expand >}}

По мере усложнения ваших ботов, количетсво хэндлеров будет расти, это факт. Чтобы не запутаться, логично разнести обработчики по разным файлам, основываясь на их предназначении. Особенно это актуально для создания диалогов при помощи конечных автоматов. В этом уроке мы будем придерживаться правила «один файл — один диалог». Но обо всём по порядку.

## Разбиваем хэндлеры по файлам

Перейдите в директорию, где будет ваш будущий бот и создайте три объекта: файлы `bot.py` и `misc.py`, а также каталог `handlers`. В последнем будут располагаться хэндлеры. Откройте каталог handlers и создайте внутри ещё три файла: `__init__.py` (два нижних подчёркивания, слово **init**, ещё два нижних подчёркивания, точка и два английских символа “пи” и “уай”), `general_commands.py` и `default_handler.py`.

Почему такое странное название у файла со словом init? Дело в том, что Python вложенные каталоги может считать отдельными модулями, что мы и будем использовать, а название __init__ — служебное обозначение, принятое в языке. Внутри файла мы просто сделаем импорт всех нужных файлов с хэндлерами, но держа в голове важное правило: как и раньше, порядок включения файлов крайне важен!   Например, если вы импортируете файл **A** с хэндлером на стикеры, а затем файл **Б** с точно таким же хэндлером, выполнится тот, что в файле **А**.

Итак, содержимое файла `__init.__py`:

{{< highlight none >}}
from . import general_commands
from . import default_handler
{{< /highlight >}}

И всё. Если в каталоге handlers появятся новые файлы, нужно будет просто отредактировать `__init__.py`, соблюдая нужный порядок. Теперь на минуту отвлечёмся от хэндлеров и подготовим самого бота. В `misc.py` просто объявим объект `Bot`:

{{< highlight none >}}
import logging
from aiogram import Bot, Dispatcher

bot = Bot(token="ВАШ_ТОКЕН")
dp = Dispatcher(bot)
logging.basicConfig(level=logging.INFO)
{{< /highlight >}}

В файле `bot.py` (он будет точкой входа) подключим созданный выше `misc.py`, каталог `handlers` и пропишем код для запуска поллинга:

{{< highlight none >}}
from aiogram import executor
from misc import dp
import handlers

if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
{{< /highlight >}}

Вернёмся к хэндлерам и создадим парочку в разных файлах.
Содержимое `general_commands.py`:

{{< highlight none >}}
from aiogram import types
from misc import dp

@dp.message_handler(commands=['start'])
async def cmd_start(message: types.Message):
    await message.answer("Обработчик команды /start")
{{< /highlight >}}

Содержимое `default_handler.py`:

{{< highlight none >}}
from aiogram import types
from lesson_14.misc import dp


@dp.message_handler(content_types=types.ContentTypes.ANY)
async def all_other_messages(message: types.Message):
    await message.answer("Любое другое сообщение")
{{< /highlight >}}

Результат:
{{% img "l14_1.png" %}}Хэндлеры из разных файлов{{% /img %}}

## Снова конечные автоматы

Судя по вашим, дорогие читатели, отзывам и вопросам, [11-й урок]({{< relref "/docs/lesson_11" >}}) этого учебника оказался самым популярным и востребованным. Действительно, довольно часто возникает потребность сделать многоуровневую логику, постепенно собирая всю информацию для последующей обработки.  

В aiogram уже встроен механизм конечных автоматов с поддержкой различных хранилищ. Чтобы не усложнять материал, мы воспользуемся самым простым и ненадёжным типом: **MemoryStorage**. Как понятно из названия, он хранит «состояния» в оперативной памяти, из-за чего при любом завершении работы бота, успешном или неуспешном, вся информация бесследно исчезает. Все поддерживаемые типы хранилищ можно посмотреть [на GitHub](https://github.com/aiogram/aiogram/tree/master/aiogram/contrib/fsm_storage).

Поставим перед собой следующую задачу: написать бота, который будет предлагать пользователю выбрать в кафе еду или напитки, а затем уточнять их выбор. На первом шаге выбирается пункт меню по названию, затем размер порции, а в конце выводится выбранный продукт. Если пользователь выполняет команду `/cancel` или пишет «отмена» (в любом регистре), прекращаем обработку.

Создадим в каталоге handlers два файла: `food.py` и `drinks.py`. Их содержимое будет очень похоже, поэтому в самом уроке мы рассмотрим только `food.py`. Для начала, импортируем все нужные объекты:

{{< highlight none >}}
from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from misc import dp
{{< /highlight >}}

Список блюд и возможные размеры порций тоже объявим прямо в коде, хотя обычно такие вещи подгружаются из других источников (например, из базы данных):

{{< highlight none >}}
available_food_names = ["суши", "спагетти", "хачапури"]
available_food_sizes = ["маленькую", "среднюю", "большую"]
{{< /highlight >}}

Создадим новый класс **OrderFood**, который, в свою очередь, наследуется от класса **StatesGroup**. В aiogram «состояния» можно объединять в группы, это удобно и несколько упрощает код.  Пропишем «состояния» в том порядке, в котором они будут использоваться пользователем (т.е. шаг1 -> шаг2 -> шаг3 и т.д.):

{{< highlight none >}}
class OrderFood(StatesGroup):
    waiting_for_food_name = State()
    waiting_for_food_size = State()
{{< /highlight >}}

Начало диалога про блюда всегда будет начинаться с команды `/food`. Если бот её получил, то надо забыть всё, что было раньше, и заняться обработкой этой ветки диалога. Внимательно посмотрите на следующий кусок кода:

{{< gist MasterGroosha 17775abb5b1e417d39a4dd58f2ed6c43 "food_step_1.py" >}}

Обратите внимание на подхэндлерное выражение. Помимо знакомого аргумента **commands** появился ещё один: **state**. При использовании конечных автоматов, очень важно указывать «состояние», которое должно быть у конкретного пользователя, чтобы хэндлер сработал. В данном случае выставлено значение "*", что означает «при любом состоянии». Т.е. независимо от текущего шага в каком-либо диалоге, отправка команды `/food` всегда попадёт в этот хэндлер.  
В последней строке функции мы назначаем текущему пользователю состояние «ожидаем ввод названия блюда». Фреймворк aiogram сам поймёт, о каком пользователе речь, основываясь на сочетании `user_id` и `chat_id`, нам, как использующим фреймворк, об этом думать необязательно.

Следующий хэндлер должен срабатывать только при активном состоянии "OrderFood.waiting_for_food_name" и если сообщение является обычным текстом, а не стикером или чем-либо ещё. На предыдущем шаге мы показали пользователю клавиатуру, поэтому дополнительно проверяем полученный текст в списке доступных блюд.

{{< gist MasterGroosha 17775abb5b1e417d39a4dd58f2ed6c43 "food_step_2.py" >}}

Опять что-то новое! На этот раз, помимо аргумента message, в подхэндлерную функцию передаём второй аргумент `state`, имеющий тип **FSMContext**. Дело в том, что aiogram позволяет вместе с «состоянием» пользователя хранить дополнительную информацию, например, промежуточные результаты. Всё это складывается в отдельный словарь (dict). В нашем случае после выполнения хэндлера в «индивидуальном словаре» конкретного пользователя под ключом `chosen_food` будет храниться текст сообщения, приведённый к строчным буквам. Если пользователь ввёл что-то, отличное от показанного меню, хэндлер завершится раньше времени и «состояние» никак не изменится, что даст возможность пользователю попробовать ещё раз. Если же введённый текст окажется корректным, то бот отправлет новую клавиатуру и переключает «состояние» на следующее (вызов функции `next()`). Именно для этого нужно соблюдать порядок описания «состояний» в группе. Разумеется, можно было бы указать новое состояние вручную.

Последний хэндлер станет обобщающим. Прежде всего, проверим, совпадает ли введённый пользователем текст с какой-либо из кнопок клавиатуры, предложенной на предыдущем шаге. Если всё верно, достаём «индивидуальный словарь» пользователя извлекаем оттуда название блюда и формируем сообщение, содержащее все выбранные ранее элементы. Напоследок очищаем «состояние» пользователя, вызвав метод `finish()`:

{{< gist MasterGroosha 17775abb5b1e417d39a4dd58f2ed6c43 "food_step_3.py" >}}

Проверяем, как всё вместе работает:

{{% img "l14_2.png" %}}Пошаговый ввод данных{{% /img %}}

Готово! Как видите, работа с конечными автоматами в aiogram проще, удобнее и приятнее, чем в pyTelegramBotAPI. Исходные тексты к уроку со всеми хэндлерами можно найти [на Github](https://github.com/MasterGroosha/telegram-tutorial/tree/master/lesson_14).

## Бонус

Начиная с [Bot API v4.7](https://core.telegram.org/bots/api-changelog#march-30-2020) боты могут самостоятельно редактировать список своих команд, отображаемых в интерфейсе приложений при вводе символа "/". Напишем хэндлер, который устанавливает для бота команды `/drinks` и `/food`:

{{< gist MasterGroosha 17775abb5b1e417d39a4dd58f2ed6c43 "cmd_set_commands.py" >}}

Не забудьте перезапустить приложение Telegram, чтобы увидеть изменения. Кстати, если передать пустой список, то можно очистить список команд, чего так долго не хватало при общении с [@BotFather](https://t.me/botfather).

{{< btn_left relref="/docs/lesson_13" >}}Урок №13{{< /btn_left >}}