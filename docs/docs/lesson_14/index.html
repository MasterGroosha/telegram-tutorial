<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css><meta property=og:title content="Пишем ботов для Telegram на языке Python"><meta property=og:image content=https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828><meta property=og:description content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_14\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</h1></header><article class=markdown><h2 id=введение>Введение</h2><p>Сегодня мы научимся раскидывать хэндлеры по разным файлам, чтобы не плодить огромные портянки кода, а также познакомимся с механизмом FSM (Finite State Machine, конечный автомат состояний), но уже в библиотеке aiogram.</p><div class=book-expand><label><div class="book-expand-head flex justify-between"><span>Примечание</span>
<span>↕</span></div><input type=checkbox style=display:none><div class="book-expand-content markdown-inner">Если по какой-то причине вы всё ещё используете pyTelegramBotAPI, то информация о FSM для него доступна в <a href=/telegram-tutorial/docs/lesson_11/>уроке 11</a>.<br>Все исходные коды к этому уроку актуальны для aiogram версии 2.x. В будущем, когда выйдет третья версия фреймворка, этот урок может быть неактуален.</div></label></div><p>По мере усложнения ваших ботов, количетсво хэндлеров будет расти, это факт. Чтобы не запутаться, логично разнести обработчики по разным файлам, основываясь на их предназначении. Особенно это актуально для создания диалогов при помощи конечных автоматов. В этом уроке мы будем придерживаться правила «один файл — один диалог». Но обо всём по порядку.</p><h2 id=разбиваем-хэндлеры-по-файлам>Разбиваем хэндлеры по файлам</h2><p>Перейдите в директорию, где будет ваш будущий бот и создайте три объекта: файлы <code>bot.py</code> и <code>misc.py</code>, а также каталог <code>handlers</code>. В последнем будут располагаться хэндлеры. Откройте каталог handlers и создайте внутри ещё три файла: <code>__init__.py</code> (два нижних подчёркивания, слово <strong>init</strong>, ещё два нижних подчёркивания, точка и два английских символа “пи” и “уай”), <code>general_commands.py</code> и <code>default_handler.py</code>.</p><p>Почему такое странное название у файла со словом init? Дело в том, что Python вложенные каталоги может считать отдельными модулями, что мы и будем использовать, а название <strong>init</strong> — служебное обозначение, принятое в языке. Внутри файла мы просто сделаем импорт всех нужных файлов с хэндлерами, но держа в голове важное правило: как и раньше, порядок включения файлов крайне важен! Например, если вы импортируете файл <strong>A</strong> с хэндлером на стикеры, а затем файл <strong>Б</strong> с точно таким же хэндлером, выполнится тот, что в файле <strong>А</strong>.</p><p>Итак, содержимое файла <code>__init.__py</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>from . import general_commands
from . import default_handler</code></pre></div><p>И всё. Если в каталоге handlers появятся новые файлы, нужно будет просто отредактировать <code>__init__.py</code>, соблюдая нужный порядок. Теперь на минуту отвлечёмся от хэндлеров и подготовим самого бота. В <code>misc.py</code> просто объявим объект <code>Bot</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>import logging
from aiogram import Bot, Dispatcher

bot = Bot(token=&#34;ВАШ_ТОКЕН&#34;)
dp = Dispatcher(bot)
logging.basicConfig(level=logging.INFO)</code></pre></div><p>В файле <code>bot.py</code> (он будет точкой входа) подключим созданный выше <code>misc.py</code>, каталог <code>handlers</code> и пропишем код для запуска поллинга:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>from aiogram import executor
from misc import dp
import handlers

if __name__ == &#34;__main__&#34;:
    executor.start_polling(dp, skip_updates=True)</code></pre></div><p>Вернёмся к хэндлерам и создадим парочку в разных файлах.
Содержимое <code>general_commands.py</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>from aiogram import types
from misc import dp

@dp.message_handler(commands=[&#39;start&#39;])
async def cmd_start(message: types.Message):
    await message.answer(&#34;Обработчик команды /start&#34;)</code></pre></div><p>Содержимое <code>default_handler.py</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>from aiogram import types
from lesson_14.misc import dp


@dp.message_handler(content_types=types.ContentTypes.ANY)
async def all_other_messages(message: types.Message):
    await message.answer(&#34;Любое другое сообщение&#34;)</code></pre></div><p>Результат:
<center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l14_1.png alt="Хэндлеры из разных файлов"><figcaption><h4><i>Хэндлеры из разных файлов</i></h4></figcaption></figure></center></p><h2 id=снова-конечные-автоматы>Снова конечные автоматы</h2><p>Судя по вашим, дорогие читатели, отзывам и вопросам, <a href=/telegram-tutorial/docs/lesson_11/>11-й урок</a> этого учебника оказался самым популярным и востребованным. Действительно, довольно часто возникает потребность сделать многоуровневую логику, постепенно собирая всю информацию для последующей обработки.</p><p>В aiogram уже встроен механизм конечных автоматов с поддержкой различных хранилищ. Чтобы не усложнять материал, мы воспользуемся самым простым и ненадёжным типом: <strong>MemoryStorage</strong>. Как понятно из названия, он хранит «состояния» в оперативной памяти, из-за чего при любом завершении работы бота, успешном или неуспешном, вся информация бесследно исчезает. Все поддерживаемые типы хранилищ можно посмотреть <a href=https://github.com/aiogram/aiogram/tree/master/aiogram/contrib/fsm_storage>на GitHub</a>.</p><p>Поставим перед собой следующую задачу: написать бота, который будет предлагать пользователю выбрать в кафе еду или напитки, а затем уточнять их выбор. На первом шаге выбирается пункт меню по названию, затем размер порции, а в конце выводится выбранный продукт. Если пользователь выполняет команду <code>/cancel</code> или пишет «отмена» (в любом регистре), прекращаем обработку.</p><p>Создадим в каталоге handlers два файла: <code>food.py</code> и <code>drinks.py</code>. Их содержимое будет очень похоже, поэтому в самом уроке мы рассмотрим только <code>food.py</code>. Для начала, импортируем все нужные объекты:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from misc import dp</code></pre></div><p>Список блюд и возможные размеры порций тоже объявим прямо в коде, хотя обычно такие вещи подгружаются из других источников (например, из базы данных):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>available_food_names = [&#34;суши&#34;, &#34;спагетти&#34;, &#34;хачапури&#34;]
available_food_sizes = [&#34;маленькую&#34;, &#34;среднюю&#34;, &#34;большую&#34;]</code></pre></div><p>Создадим новый класс <strong>OrderFood</strong>, который, в свою очередь, наследуется от класса <strong>StatesGroup</strong>. В aiogram «состояния» можно объединять в группы, это удобно и несколько упрощает код. Пропишем «состояния» в том порядке, в котором они будут использоваться пользователем (т.е. шаг1 -&gt; шаг2 -&gt; шаг3 и т.д.):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>class OrderFood(StatesGroup):
    waiting_for_food_name = State()
    waiting_for_food_size = State()</code></pre></div><p>Начало диалога про блюда всегда будет начинаться с команды <code>/food</code>. Если бот её получил, то надо забыть всё, что было раньше, и заняться обработкой этой ветки диалога. Внимательно посмотрите на следующий кусок кода:</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_1.py"></script><p>Обратите внимание на подхэндлерное выражение. Помимо знакомого аргумента <strong>commands</strong> появился ещё один: <strong>state</strong>. При использовании конечных автоматов, очень важно указывать «состояние», которое должно быть у конкретного пользователя, чтобы хэндлер сработал. В данном случае выставлено значение &ldquo;*&ldquo;, что означает «при любом состоянии». Т.е. независимо от текущего шага в каком-либо диалоге, отправка команды <code>/food</code> всегда попадёт в этот хэндлер.<br>В последней строке функции мы назначаем текущему пользователю состояние «ожидаем ввод названия блюда». Фреймворк aiogram сам поймёт, о каком пользователе речь, основываясь на сочетании <code>user_id</code> и <code>chat_id</code>, нам, как использующим фреймворк, об этом думать необязательно.</p><p>Следующий хэндлер должен срабатывать только при активном состоянии &ldquo;OrderFood.waiting_for_food_name&rdquo; и если сообщение является обычным текстом, а не стикером или чем-либо ещё. На предыдущем шаге мы показали пользователю клавиатуру, поэтому дополнительно проверяем полученный текст в списке доступных блюд.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_2.py"></script><p>Опять что-то новое! На этот раз, помимо аргумента message, в подхэндлерную функцию передаём второй аргумент <code>state</code>, имеющий тип <strong>FSMContext</strong>. Дело в том, что aiogram позволяет вместе с «состоянием» пользователя хранить дополнительную информацию, например, промежуточные результаты. Всё это складывается в отдельный словарь (dict). В нашем случае после выполнения хэндлера в «индивидуальном словаре» конкретного пользователя под ключом <code>chosen_food</code> будет храниться текст сообщения, приведённый к строчным буквам. Если пользователь ввёл что-то, отличное от показанного меню, хэндлер завершится раньше времени и «состояние» никак не изменится, что даст возможность пользователю попробовать ещё раз. Если же введённый текст окажется корректным, то бот отправлет новую клавиатуру и переключает «состояние» на следующее (вызов функции <code>next()</code>). Именно для этого нужно соблюдать порядок описания «состояний» в группе. Разумеется, можно было бы указать новое состояние вручную.</p><p>Последний хэндлер станет обобщающим. Прежде всего, проверим, совпадает ли введённый пользователем текст с какой-либо из кнопок клавиатуры, предложенной на предыдущем шаге. Если всё верно, достаём «индивидуальный словарь» пользователя извлекаем оттуда название блюда и формируем сообщение, содержащее все выбранные ранее элементы. Напоследок очищаем «состояние» пользователя, вызвав метод <code>finish()</code>:</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=food_step_3.py"></script><p>Проверяем, как всё вместе работает:</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l14_2.png alt="Пошаговый ввод данных"><figcaption><h4><i>Пошаговый ввод данных</i></h4></figcaption></figure></center></p><p>Готово! Как видите, работа с конечными автоматами в aiogram проще, удобнее и приятнее, чем в pyTelegramBotAPI. Исходные тексты к уроку со всеми хэндлерами можно найти <a href=https://github.com/MasterGroosha/telegram-tutorial/tree/master/lesson_14>на Github</a>.</p><h2 id=бонус>Бонус</h2><p>Начиная с <a href=https://core.telegram.org/bots/api-changelog#march-30-2020>Bot API v4.7</a> боты могут самостоятельно редактировать список своих команд, отображаемых в интерфейсе приложений при вводе символа &ldquo;/&rdquo;. Напишем хэндлер, который устанавливает для бота команды <code>/drinks</code> и <code>/food</code>:</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/17775abb5b1e417d39a4dd58f2ed6c43.js?file=cmd_set_commands.py"></script><p>Не забудьте перезапустить приложение Telegram, чтобы увидеть изменения. Кстати, если передать пустой список, то можно очистить список команд, чего так долго не хватало при общении с <a href=https://t.me/botfather>@BotFather</a>.</p><a href=/telegram-tutorial/docs/lesson_13/ class=book-btn style=float:left>← Урок №13</a></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><ul><li><a href=#введение>Введение</a></li><li><a href=#разбиваем-хэндлеры-по-файлам>Разбиваем хэндлеры по файлам</a></li><li><a href=#снова-конечные-автоматы>Снова конечные автоматы</a></li><li><a href=#бонус>Бонус</a></li></ul></li></ul></nav></aside></main></body></html>