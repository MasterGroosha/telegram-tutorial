<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 13. Опросы v2.0
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7c4a27ae7333f2fd90f74328a06079ce9a887b15763d645a1ce5ad459fe9881.css><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828"><meta property="og:description" content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_13\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 13. Опросы v2.0</h1></header><article class=markdown><h2 id=heading>Введение</h2><p>Добро пожаловать в 2020! В последний раз мы рассматривали нововведения Bot API аж в далёком 2017 году, когда появилось <a href=https://mastergroosha.github.io/telegram-tutorial/docs/lesson_10>удаление сообщений и ограничения в чатах</a>. С тех пор вышло много чего интересного и, возможно, о чём-то стоит выпустить отдельные уроки.</p><p>А сегодня мы познакомимся с <a href=https://telegram.org/blog/polls-2-0-vmq>опросами 2.0</a>, точнее, с новой сущностью: викторинами (quiz). Викторина – это именно то, что вы и предположили; тест с одним правильными вариантом ответа и ещё N неправильными.</p><p>Поставим себе задачу сделать бота, который умеет:</p><ol><li>принимать от пользователя только викторины;</li><li>запоминать их содержимое и записывать к себе в память;</li><li>предлагать викторины в инлайн-запросе и отправляет их в группу;</li><li>получать новые ответы и сохранять ID правильно ответивших;</li><li>останавливать викторину после <strong>двух</strong> правильных ответов и поздравлять победителей.</li></ol><p>Задач много, придётся вспомнить, что такое колбэки, инлайн-режим и классы. Но и это не самое главное…</p><h2 id=---telebot---aiogram>Пятиминутка ненависти к telebot или Привет, aiogram!</h2><p>Как вы знаете, во всех предыдущих уроках использовалась библиотека <a href=https://github.com/eternnoir/pyTelegramBotAPI>pyTelegramBotAPI</a>, именуемая в коде telebot. В 2015-2017 годах, возможно, она ещё была актуальна, но прогресс не стоит на месте. А telebot, увы, стоит. Кривая реализация поллинга, проблемный next_step_handler, медленная поддержка новых версий Bot API и т.д.</p><p>В течение 2019 года я постепенно переносил своих ботов на другой фреймворк, который по многим пунктам превосходит pyTelegramBotAPI, и имя ему – <a href=https://github.com/aiogram/aiogram>aiogram</a>. «Почему?», спросит меня уважаемый читатель. Что ж, приведу следующие аргументы:</p><ul><li>это полноценный фреймворк, т.е. позволяет сделать больше полезных вещей;</li><li>асинхронный, что делает его быстрее в некоторых задачах;</li><li>поддерживается Python 3.7+ и выше, что сподвигнет обновить свой старенький интерпретатор и использовать новые возможности языка;</li><li>множество встроенных «помощников» (синтаксический «сахар»), улучшающих читабельность кода;</li><li>оперативные обновления (поддержка новых опросов появилась в тот же день, что и в самом Bot API);</li><li>русскоязычный <a href=https://t.me/aiogram_ru>чат</a> поддержки и обсуждений, где сидит, в том числе, и сам разработчик фреймворка;</li><li>мой любимый пункт: нормально работающий поллинг.</li></ul><p>Прокомментирую последний пункт: в настоящий момент почти все мои боты работают на aiogram-ном поллинге и не падают ежедневно, как в случае с pyTelegramBotAPI.<br><strong>Важный момент</strong>: чтобы использовать aiogram в Windows, нужны C++ Build Tools, которые входят в поставку Visual Studio (не VSCode!). В Linux таких «проблем» нет, к слову.</p><p>Введение получилось очень большим, поэтому давайте уже перейдём к делу.</p><h2 id=-->Плацдарм для бота</h2><p>Напишем элементарного эхо-бота на aiogram с поллингом, чтобы бегло ознакомиться с фреймворком. Прежде всего, добавим нужные импорты (предполагается, что мы используем Virtual Environment, подробнее о нём – в <a href=https://mastergroosha.github.io/telegram-tutorial/docs/lesson_00/>уроке №0</a>):</p><pre><code class=language-none data-lang=none>#!venv/bin/python
import logging
from aiogram import Bot, Dispatcher, executor, types
logging.basicConfig(level=logging.INFO)</code></pre><p>Теперь создадим объект бота. А за хэндлеры здесь отвечает специальный Диспетчер:</p><pre><code class=language-none data-lang=none>bot = Bot(token="12345678:AABcdeFGhIJkXyZ")
dp = Dispatcher(bot)</code></pre><p>Далее напишем простейший хэндлер, повторяющий текстовые сообщения:</p><pre><code class=language-none data-lang=none>@dp.message_handler()
async def echo(message: types.Message):
    await message.reply(message.text)</code></pre><p>Началась магия.<br>Во-первых, как я написал чуть выше, за хэндлеры отвечает диспетчер (dp).<br>Во-вторых, подхэндлерные функции в aiogram асинхронные (async def), что влечёт за собой необходимость ставить ключевое слово await перед любыми действиями бота.<br>В-третьих, вместо <code>bot.send_message</code> можно для удобства использовать <code>message.reply( )</code> без указания <code>chat_id</code> и <code>message.id</code>, чтобы бот сделал «ответ» (reply), либо аналог <code>message.answer( )</code>, чтобы просто отправить в тот же чат, не создавая «ответ». Само выражение в хэндлере пустое, т.к. нас устроят любые текстовые сообщения.</p><p>Наконец, запуск!<br><pre><code class=language-none data-lang=none>if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)</code></pre></p><p>Параметр <code>skip_updates=True</code> позволяет пропустить накопившиеся входящие сообщения, если они нам не важны.<br>Запускаем код, убеждаемся в его работоспособности, после чего удаляем хэндлер вместе с функцией echo, нам они больше не понадобятся, в отличие от остального кода.</p><h2 id=--->Запрашиваем викторину у пользователя</h2><p>В BotAPI 4.6 появилась новая кнопка для обычной (не инлайн) клавиатуры с типом <a href=https://core.telegram.org/bots/api#keyboardbuttonpolltype>KeyboardButtonPollType</a>. При нажатии на неё в приложении Telegram появляется окно для создания опроса. В самой кнопке можно выставить ограничение по типу создаваемого объекта: опрос, викторина или что угодно. Опросы нас пока не интересуют, поэтому напишем обработчик команды <code>/start</code>, выводящий приветственное сообщение и обычную клавиатуру с двумя кнопками: “Создать викторину” и “Отмена”, причём вторая отправляет <a href=https://core.telegram.org/bots/api#replykeyboardremove>ReplyKeyboardRemove</a>, удаляя первую клавиатуру.</p><pre><code class=language-none data-lang=none># Хэндлер на команду /start
@dp.message_handler(commands=["start"])
async def cmd_start(message: types.Message):
    poll_keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    poll_keyboard.add(types.KeyboardButton(text="Создать викторину",
                                           request_poll=types.KeyboardButtonPollType(type=types.PollType.QUIZ)))
    poll_keyboard.add(types.KeyboardButton(text="Отмена"))
    await message.answer("Нажмите на кнопку ниже и создайте викторину!", reply_markup=poll_keyboard)

# Хэндлер на текстовое сообщение с текстом “Отмена”
@dp.message_handler(lambda message: message.text == "Отмена")
async def action_cancel(message: types.Message):
    remove_keyboard = types.ReplyKeyboardRemove()
    await message.answer("Действие отменено. Введите /start, чтобы начать заново.", reply_markup=remove_keyboard)</code></pre><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l13_1.png alt="Клавиатура с кнопками"><figcaption><h4><i>Клавиатура с кнопками</i></h4></figcaption></figure></center><h2 id=---1>Сохраняем и предлагаем</h2><p>В <a href=https://mastergroosha.github.io/telegram-tutorial/docs/lesson_11/>11-м уроке</a> я использовал библиотеку <a href=https://github.com/coleifer/vedis-python>Vedis</a> для сохранения состояний в файле, чтобы те не сбрасывались после перезагрузки бота. В этот раз мы будем сохранять всё в памяти, а выбор постоянного хранилища останется за читателем, чтобы не навязывать то или иное решение. Разумеется, данные в памяти сотрутся при остановке бота, но для примера так даже лучше.</p><p>Наше хранилище будет основано на стандартных питоновских словарях (dict), причём их будет два: первый словарь содержит пары (&ldquo;id пользователя&rdquo;, &ldquo;массив сохранённых викторин&rdquo;), а второй — пары (&ldquo;id викторины&rdquo;, &ldquo;id автора викторины&rdquo;). Зачем два словаря? В дальнейшем нам нужно будет по идентификатору викторины получать некоторую информацию о ней. Необходимые нам сведения лежат в первом словаре, но в виде значений, а не ключей. Поэтому нам пришлось бы проходиться по всем возможным парам ключ-значение, чтобы найти нужную викторину.</p><p>Для ускорения поиска мы заведём второй словарь, чтобы по идентификатору викторины сразу же найти идентификатор её автора, который, в свою очередь, является ключом в первом словаре. А дальше проход по небольшому массиву и вуаля! Наши данные получены. На словах звучит сложно, но на практике реализуется довольно быстро и с минимальной избыточностью. Если придумаете решение лучше — пишите, буду рад исправить текст.</p><p>Помимо определения викторины, нам нужно хранить некоторую дополнительную информацию. Поэтому давайте создадим файл <code>quizzer.py</code>, опишем наш класс <strong>Quiz</strong> со всеми нужными полями в конструкторе класса (обратите внимание, в конструктор передаются не все поля, т.к. часть из них будет заполнена позднее):</p><pre><code class=language-none data-lang=none>from typing import List

class Quiz:
    type: str = "quiz"

    def __init__(self, quiz_id, question, options, correct_option_id, owner_id):
        # Используем подсказки типов, чтобы было проще ориентироваться.
        self.quiz_id: str = quiz_id   # ID викторины. Изменится после отправки от имени бота
        self.question: str = question  # Текст вопроса
        self.options: List[str] = [*options] # "Распакованное" содержимое массива m_options в массив options
        self.correct_option_id: int = correct_option_id  # ID правильного ответа
        self.owner: int = owner_id  # Владелец опроса
        self.winners: List[int] = []  # Список победителей
        self.chat_id: int = 0  # Чат, в котором опубликована викторина
        self.message_id: int = 0  # Сообщение с викториной (для закрытия)</code></pre><p>Если вы раньше не сталкивались с подсказками типов (type hints), код вида “chat_id: int = 0” может ввести в замешательство. Здесь <code>chat_id</code> — это имя переменной, далее через двоеточие <code>int</code> — её тип (число), а дальше инициализация числом 0. Python по-прежнему является языком с динамической типизацией, отсюда и название “подсказка типа”. В реальности это влияет только на восприятие кода и предупреждения в полноценных IDE типа PyCharm. Никто не мешает вам написать <code>quiz_id: int = "чемодан"</code>, но зачем так делать?
Вернёмся в наш основной файл (я его далее буду называть <code>bot.py</code>) и импортируем наш класс: <code>from quizzer import Quiz</code>. Также добавим в начале файла под определением бота два пустых словаря:</p><pre><code class=language-none data-lang=none>quizzes_database = {}  # здесь хранится информация о викторинах
quizzes_owners = {}  # здесь хранятся пары "id викторины <—> id её создателя"</code></pre><p>Теперь будем отлавливать викторины, приходящие в бота. Как только прилетает что-то, похожее на неё, извлекаем информацию и создаём две записи. В первом словаре храним параметры викторины, чтобы потом её воспроизвести, а во втором просто создаём пару викторина-создатель. Идентификаторы, составляющие ключ словаря, конвертируем в строки методом <code>str()</code>:</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=04_content_types_poll.py"></script><p>Раз уж мы сохраняем викторины, давайте теперь позволим пользователям их отправлять, причём через инлайн-режим. Есть одна загвоздка: в BotAPI через инлайн-режим нельзя напрямую отправлять опросы (нет объекта InlineQueryResultPoll), поэтому придётся доставать костыли. Будем возвращать обычное сообщение с URL-кнопкой вида https://t.me/нашбот?startgroup=id_викторины. Параметры startgroup и start — это т.н. &ldquo;глубокие ссылки&rdquo; (<a href=https://core.telegram.org/bots/#deep-linking>Deep Linking</a>). Когда пользователь нажмёт на кнопку, он перейдёт по указанной выше ссылке, что, в свою очередь, благодаря параметру <code>startgroup</code> перекинет его к выбору группы, а затем, уже после подтверждения выбора, бот будет добавлен в группу с вызовом команды <code>/start id_викторины</code>.</p><p>Начнём разбираться с инлайн-режимом (не забудьте включить его у <a href=https://t.me/botfather>@BotFather</a>). Когда пользователь вызывает нашего бота через инлайн, показываем все созданные им викторины, плюс кнопку &ldquo;Создать новую&rdquo;. Если ничего нет, то только кнопку.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=05_inline_handler.py"></script><p>Очень важно выставить флаг <code>is_personal</code> равным <strong>True</strong> (ответ на запрос будет уникален для каждого Telegram ID) и указать небольшое значение параметра <code>cache_time</code>, чтобы кэш инлайн-ответов оперативно обновлялся по мере появления новых викторин.<br>Теперь при вызове бота через инлайн мы увидим наши сохранённые викторины, а при выборе одной из них — сообщение с кнопкой, по нажатию на которую нам предложат выбрать группу для отправки сообщения. Как только группа будет выбрана, в неё будет автоматически добавлен бот с сообщением вида <code>/start@имя_бота</code>. Но ничего не происходит! Сейчас разберёмся.</p><h2 id=---->Отправляем викторину и получаем ответы</h2><p>Помните наш простой обработчик команды <code>/start</code>, возвращающий сообщение с кнопкой? Настало время переписать этот хэндлер. Первым делом, будем проверять, куда отправлено сообщение &ndash; в диалог с ботом или нет. Если в диалог, то всё остаётся по-прежнему: приветствие (на этот раз укажем, что викторина принудительно будет сделана неанонимной) и кнопка для создания викторины.</p><p>А вот если сообщение отправлено в группу, то применяем следующую логику: проверяем количество “слов” в сообщении. Одно всегда есть (команда <code>/start</code>), но может быть и второе, невидимое в интерфейсе приложения Telegram &ndash; параметр, переданный в качестве параметра <code>startgroup</code>, в нашем случае это ID викторины. Если второго слова нет (количество слов = 1), то показываем сообщение с предложением перейти в личку к боту с принудительным показом кнопки <code>/start</code>.</p><p>В случае, если второе слово есть, то считаем его идентификатором и пробуем отправить викторину в ту же группу. При этом мы, по сути, воспроизводим её [викторину] заново, просто от своего имени: повторяем вопрос, варианты ответов и отключаем анонимный режим, т.к. нам нужно знать, кто победитель.</p><p><strong>Очень важный момент</strong>: при отправке викторины, в объекте <code>Message</code> будет записан уже новый её идентификатор, который нужно подставить в наши словари. Далее по этому новому ID мы будем смотреть и считать ответы. Побочным эффектом такого подхода будет возможность использования конкретной викторины лишь однажды и в одном чате, если отправить сообщение из инлайна в другой чат, то зашитый в ссылке инлайн-кнопки ID будет недействительным.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=02_new_start_handler.py"></script><p>Далее необходимо научиться как-то обрабатывать новые ответы. В свежем обновлении API добавилось два новых типа обновлений (updates, т.е. входящие события): <code>PollAnswer</code> и просто <code>Poll</code>. Первый срабатывает при получении новых ответов в викторинах и опросах, в последнем случае ещё и при отзыве голоса (массив голосов от пользователя будет пустой). Второй срабатывает при изменении состояния опроса в целом, т.е. не только при получении новых ответов/голосов, но и при смене состояния &ldquo;открыт/закрыт&rdquo; и др. Опять-таки, в обучающих целях мы задействуем хэндлеры на оба типа событий.</p><p>Начнём с <code>PollAnswer</code>. Когда прилетает событие с новым ответом на викторину, прежде всего достаём её ID, по ней ищем автора во втором словаре. Если находим, то гуляем по всем викторинам этого пользователя и ищем совпадение по ID самой викторины, т.е. в точности обратное действие, только уже в первом словаре. Когда обнаружится нужная викторина, то проверяем, верный ответ или нет (сравниваем с <code>correct_option_id</code>), и если да, то записываем ID пользователя в список победителей. Если количество победителей при этом достигает двух, то останавливаем викторину.</p><p>Остановка викторины (метод <a href=https://core.telegram.org/bots/api#stoppoll>stop_poll( )</a>) вызовет срабатывание хэндлера на тип обновлений <code>Poll</code> с условием <code>is_closed is True</code>. Снова извлекаем нужный нам экземпляр класса <strong>Quiz</strong>, вытаскиваем ID победителей и вызываем метод <a href=https://core.telegram.org/bots/api#getchatmember>get_chat_member</a>, после чего, используя aiogram-ный вспомогательный метод <code>get_mention</code>, формируем ссылку на каждого из победителей в HTML-разметке и создаём поздравительное сообщение. Викторины у нас одноразовые, поэтому подчищаем за собой словари, дабы не раздувать объекты в памяти.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=03_poll_handlers.py"></script><p>Код готов. Закинем викторину в группу и попросим друзей правильно ответить, а сами ответим неправильно.
После первого правильного ответа:</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l13_2.png alt="2 ответа, только один правильный"><figcaption><h4><i>2 ответа, только один правильный</i></h4></figcaption></figure></center><p>После второго правильного ответа:</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l13_3.png alt="3 ответа, 2 правильных, опрос закрыт"><figcaption><h4><i>3 ответа, 2 правильных, опрос закрыт</i></h4></figcaption></figure></center><p>На этом всё! Если у вас возникли вопросы, не стесняйтесь задавать их в <a href=https://t.me/joinchat/ABtnIE7H7Q3TRRh8n8uNww>нашем чатике</a>, а если вы нашли ошибку/опечатку, либо есть чем дополнить материал, то добро пожаловать на <a href=https://github.com/MasterGroosha/telegram-tutorial/issues>GitHub</a> (ну, или всё так же в чате). Полный код урока можно найти <a href=https://github.com/MasterGroosha/telegram-tutorial/tree/master/lesson_13>здесь</a>.</p><a href=/telegram-tutorial/docs/lesson_12/ class=book-btn style=float:left>← Урок №12</a></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><a href=#heading>Введение</a></li><li><a href=#---telebot---aiogram>Пятиминутка ненависти к telebot или Привет, aiogram!</a></li><li><a href=#-->Плацдарм для бота</a></li><li><a href=#--->Запрашиваем викторину у пользователя</a></li><li><a href=#---1>Сохраняем и предлагаем</a></li><li><a href=#---->Отправляем викторину и получаем ответы</a></li></ul></nav></aside></main></body></html>