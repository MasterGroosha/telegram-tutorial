<!doctype html><html lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Опросы v2.0"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:type" content="article"><meta property="og:description" content="Урок 13: Опросы v2.0"><meta property="og:url" content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_13/"><meta property="og:site_name" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png"><title>Урок 13: Опросы v2.0 | Пишем ботов для Telegram на языке Python</title><link rel=manifest href=/telegram-tutorial/manifest.json><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon><link rel=stylesheet href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a></h2><ul><li class=book-section-flat><span>pyTelegramBotAPI</span><ul><li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan (неактуально)</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></li><li class=book-section-flat><span>aiogram</span><ul><li><a href=/telegram-tutorial/docs/lesson_13/ class=active>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></li></ul><ul><li><a href=/telegram-tutorial/posts/></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Урок 13</strong>
<label for=toc-control><img src=/telegram-tutorial/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#введение>Введение</a></li><li><a href=#пятиминутка-ненависти-к-telebot-или-привет-aiogram>Пятиминутка ненависти к telebot или Привет, aiogram!</a></li><li><a href=#плацдарм-для-бота>Плацдарм для бота</a></li><li><a href=#запрашиваем-викторину-у-пользователя>Запрашиваем викторину у пользователя</a></li><li><a href=#сохраняем-и-предлагаем>Сохраняем и предлагаем</a></li><li><a href=#отправляем-викторину-и-получаем-ответы>Отправляем викторину и получаем ответы</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1>Опросы v2.0</h1><p><h2 id=введение>Введение</h2><p>Добро пожаловать в 2020! В последний раз мы рассматривали нововведения Bot API аж в далёком 2017 году, когда появилось <a href=/telegram-tutorial/docs/lesson_10/>удаление сообщений и ограничения в чатах</a>. С тех пор вышло много чего интересного и, возможно, о чём-то стоит выпустить отдельные уроки.</p><p>А сегодня мы познакомимся с <a href=https://telegram.org/blog/polls-2-0-vmq>опросами 2.0</a>, точнее, с новой сущностью: викторинами (quiz). Викторина – это именно то, что вы и предположили; тест с одним правильными вариантом ответа и ещё N неправильными.</p><p>Поставим себе задачу сделать бота, который умеет:</p><ol><li>принимать от пользователя только викторины;</li><li>запоминать их содержимое и записывать к себе в память;</li><li>предлагать викторины в инлайн-запросе и отправляет их в группу;</li><li>получать новые ответы и сохранять ID правильно ответивших;</li><li>останавливать викторину после <strong>двух</strong> правильных ответов и поздравлять победителей.</li></ol><p>Задач много, придётся вспомнить, что такое колбэки, инлайн-режим и классы. Но и это не самое главное…</p><h2 id=пятиминутка-ненависти-к-telebot-или-привет-aiogram>Пятиминутка ненависти к telebot или Привет, aiogram!</h2><p>Как вы знаете, во всех предыдущих уроках использовалась библиотека <a href=https://github.com/eternnoir/pyTelegramBotAPI>pyTelegramBotAPI</a>, именуемая в коде telebot. В 2015-2017 годах, возможно, она ещё была актуальна, но прогресс не стоит на месте. А telebot, увы, стоит. Кривая реализация поллинга, проблемный next_step_handler, медленная поддержка новых версий Bot API и т.д.</p><p>В течение 2019 года я постепенно переносил своих ботов на другой фреймворк, который по многим пунктам превосходит pyTelegramBotAPI, и имя ему – <a href=https://github.com/aiogram/aiogram>aiogram</a>. «Почему?», спросит меня уважаемый читатель. Что ж, приведу следующие аргументы:</p><ul><li>это полноценный фреймворк, т.е. позволяет сделать больше полезных вещей;</li><li>асинхронный, что делает его быстрее в некоторых задачах;</li><li>поддерживается Python 3.7+ и выше, что сподвигнет обновить свой старенький интерпретатор и использовать новые возможности языка;</li><li>множество встроенных «помощников» (синтаксический «сахар»), улучшающих читабельность кода;</li><li>оперативные обновления (поддержка новых опросов появилась в тот же день, что и в самом Bot API);</li><li>русскоязычный <a href=https://t.me/aiogram_ru>чат</a> поддержки и обсуждений, где сидит, в том числе, и сам разработчик фреймворка;</li><li>мой любимый пункт: нормально работающий поллинг.</li></ul><p>Прокомментирую последний пункт: в настоящий момент почти все мои боты работают на aiogram-ном поллинге и не падают ежедневно, как в случае с pyTelegramBotAPI.</p><p>Введение получилось очень большим, поэтому давайте уже перейдём к делу.</p><h2 id=плацдарм-для-бота>Плацдарм для бота</h2><p>Напишем элементарного эхо-бота на aiogram с поллингом, чтобы бегло ознакомиться с фреймворком. Прежде всего, добавим нужные импорты (предполагается, что мы используем Virtual Environment, подробнее о нём – в <a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>уроке №0</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:green>#!venv/bin/python</span>
<span style=color:#00f>import</span> logging
<span style=color:#00f>from</span> aiogram <span style=color:#00f>import</span> Bot, Dispatcher, executor, types
logging.basicConfig(level=logging.INFO)
</code></pre></div><p>Теперь создадим объект бота. А за хэндлеры здесь отвечает специальный Диспетчер:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>bot = Bot(token=<span style=color:#a31515>&#34;12345678:AABcdeFGhIJkXyZ&#34;</span>)
dp = Dispatcher(bot)
</code></pre></div><p>Далее напишем простейший хэндлер, повторяющий текстовые сообщения:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@dp.message_handler()
async <span style=color:#00f>def</span> echo(message: types.Message):
    await message.reply(message.text)
</code></pre></div><p>Началась магия.<br>Во-первых, как я написал чуть выше, за хэндлеры отвечает диспетчер (dp).<br>Во-вторых, подхэндлерные функции в aiogram асинхронные (async def), вызовы Bot API тоже асинхронные, поэтому необходимо использовать ключевое слово <code>await</code>.<br>В-третьих, вместо <code>bot.send_message</code> можно для удобства использовать <code>message.reply( )</code> без указания <code>chat_id</code> и <code>message.id</code>, чтобы бот сделал «ответ» (reply), либо аналог <code>message.answer( )</code>, чтобы просто отправить в тот же чат, не создавая «ответ». Само выражение в хэндлере пустое, т.к. нас устроят любые текстовые сообщения.</p><p>Наконец, запуск!</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>if</span> __name__ == <span style=color:#a31515>&#34;__main__&#34;</span>:
    executor.start_polling(dp, skip_updates=True)
</code></pre></div><p>Параметр <code>skip_updates=True</code> позволяет пропустить накопившиеся входящие сообщения, если они нам не важны.<br>Запускаем код, убеждаемся в его работоспособности, после чего удаляем хэндлер вместе с функцией echo, нам они больше не понадобятся, в отличие от остального кода.</p><h2 id=запрашиваем-викторину-у-пользователя>Запрашиваем викторину у пользователя</h2><p>В BotAPI 4.6 появилась новая кнопка для обычной (не инлайн) клавиатуры с типом <a href=https://core.telegram.org/bots/api#keyboardbuttonpolltype>KeyboardButtonPollType</a>. При нажатии на неё в приложении Telegram появляется окно для создания опроса. В самой кнопке можно выставить ограничение по типу создаваемого объекта: опрос, викторина или что угодно. Опросы нас пока не интересуют, поэтому напишем обработчик команды <code>/start</code>, выводящий приветственное сообщение и обычную клавиатуру с двумя кнопками: “Создать викторину” и “Отмена”, причём вторая отправляет <a href=https://core.telegram.org/bots/api#replykeyboardremove>ReplyKeyboardRemove</a>, удаляя первую клавиатуру.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:green># Хэндлер на команду /start</span>
@dp.message_handler(commands=[<span style=color:#a31515>&#34;start&#34;</span>])
async <span style=color:#00f>def</span> cmd_start(message: types.Message):
    poll_keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    poll_keyboard.add(types.KeyboardButton(text=<span style=color:#a31515>&#34;Создать викторину&#34;</span>,
                                           request_poll=types.KeyboardButtonPollType(type=types.PollType.QUIZ)))
    poll_keyboard.add(types.KeyboardButton(text=<span style=color:#a31515>&#34;Отмена&#34;</span>))
    await message.answer(<span style=color:#a31515>&#34;Нажмите на кнопку ниже и создайте викторину!&#34;</span>, reply_markup=poll_keyboard)

<span style=color:green># Хэндлер на текстовое сообщение с текстом “Отмена”</span>
@dp.message_handler(<span style=color:#00f>lambda</span> message: message.text == <span style=color:#a31515>&#34;Отмена&#34;</span>)
async <span style=color:#00f>def</span> action_cancel(message: types.Message):
    remove_keyboard = types.ReplyKeyboardRemove()
    await message.answer(<span style=color:#a31515>&#34;Действие отменено. Введите /start, чтобы начать заново.&#34;</span>, reply_markup=remove_keyboard)
</code></pre></div><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l13_1.png></center>
<center><i>Клавиатура с кнопками</i></center><h2 id=сохраняем-и-предлагаем>Сохраняем и предлагаем</h2><p>В <a href=/telegram-tutorial/docs/lesson_11/>11-м уроке</a> я использовал библиотеку <a href=https://github.com/coleifer/vedis-python>Vedis</a> для сохранения состояний в файле, чтобы те не сбрасывались после перезагрузки бота. В этот раз мы будем сохранять всё в памяти, а выбор постоянного хранилища останется за читателем, чтобы не навязывать то или иное решение. Разумеется, данные в памяти сотрутся при остановке бота, но для примера так даже лучше.</p><p>Наше хранилище будет основано на стандартных питоновских словарях (dict), причём их будет два: первый словарь содержит пары (&ldquo;id пользователя&rdquo;, &ldquo;массив сохранённых викторин&rdquo;), а второй — пары (&ldquo;id викторины&rdquo;, &ldquo;id автора викторины&rdquo;). Зачем два словаря? В дальнейшем нам нужно будет по идентификатору викторины получать некоторую информацию о ней. Необходимые нам сведения лежат в первом словаре, но в виде значений, а не ключей. Поэтому нам пришлось бы проходиться по всем возможным парам ключ-значение, чтобы найти нужную викторину.</p><p>Для ускорения поиска мы заведём второй словарь, чтобы по идентификатору викторины сразу же найти идентификатор её автора, который, в свою очередь, является ключом в первом словаре. А дальше проход по небольшому массиву и вуаля! Наши данные получены. На словах звучит сложно, но на практике реализуется довольно быстро и с минимальной избыточностью. Если придумаете решение лучше — пишите, буду рад исправить текст.</p><p>Помимо определения викторины, нам нужно хранить некоторую дополнительную информацию. Поэтому давайте создадим файл <code>quizzer.py</code>, опишем наш класс <strong>Quiz</strong> со всеми нужными полями в конструкторе класса (обратите внимание, в конструктор передаются не все поля, т.к. часть из них будет заполнена позднее):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>from</span> typing <span style=color:#00f>import</span> List

<span style=color:#00f>class</span> <span style=color:#2b91af>Quiz</span>:
    type: str = <span style=color:#a31515>&#34;quiz&#34;</span>

    <span style=color:#00f>def</span> __init__(self, quiz_id, question, options, correct_option_id, owner_id):
        <span style=color:green># Используем подсказки типов, чтобы было проще ориентироваться.</span>
        self.quiz_id: str = quiz_id   <span style=color:green># ID викторины. Изменится после отправки от имени бота</span>
        self.question: str = question  <span style=color:green># Текст вопроса</span>
        self.options: List[str] = [*options] <span style=color:green># &#34;Распакованное&#34; содержимое массива m_options в массив options</span>
        self.correct_option_id: int = correct_option_id  <span style=color:green># ID правильного ответа</span>
        self.owner: int = owner_id  <span style=color:green># Владелец опроса</span>
        self.winners: List[int] = []  <span style=color:green># Список победителей</span>
        self.chat_id: int = 0  <span style=color:green># Чат, в котором опубликована викторина</span>
        self.message_id: int = 0  <span style=color:green># Сообщение с викториной (для закрытия)</span>
</code></pre></div><p>Если вы раньше не сталкивались с подсказками типов (type hints), код вида “chat_id: int = 0” может ввести в замешательство. Здесь <code>chat_id</code> — это имя переменной, далее через двоеточие <code>int</code> — её тип (число), а дальше инициализация числом 0. Python по-прежнему является языком с динамической типизацией, отсюда и название “подсказка типа”. В реальности это влияет только на восприятие кода и предупреждения в полноценных IDE типа PyCharm. Никто не мешает вам написать <code>quiz_id: int = "чемодан"</code>, но зачем так делать?
Вернёмся в наш основной файл (я его далее буду называть <code>bot.py</code>) и импортируем наш класс: <code>from quizzer import Quiz</code>. Также добавим в начале файла под определением бота два пустых словаря:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>quizzes_database = {}  <span style=color:green># здесь хранится информация о викторинах</span>
quizzes_owners = {}  <span style=color:green># здесь хранятся пары &#34;id викторины &lt;—&gt; id её создателя&#34;</span>
</code></pre></div><p>Теперь будем отлавливать викторины, приходящие в бота. Как только прилетает что-то, похожее на неё, извлекаем информацию и создаём две записи. В первом словаре храним параметры викторины, чтобы потом её воспроизвести, а во втором просто создаём пару викторина-создатель. Идентификаторы, составляющие ключ словаря, конвертируем в строки методом <code>str()</code>:</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=04_content_types_poll.py"></script><p>Раз уж мы сохраняем викторины, давайте теперь позволим пользователям их отправлять, причём через инлайн-режим. Есть одна загвоздка: в BotAPI через инлайн-режим нельзя напрямую отправлять опросы (нет объекта InlineQueryResultPoll), поэтому придётся доставать костыли. Будем возвращать обычное сообщение с URL-кнопкой вида https://t.me/нашбот?startgroup=id_викторины. Параметры startgroup и start — это т.н. &ldquo;глубокие ссылки&rdquo; (<a href=https://core.telegram.org/bots/#deep-linking>Deep Linking</a>). Когда пользователь нажмёт на кнопку, он перейдёт по указанной выше ссылке, что, в свою очередь, благодаря параметру <code>startgroup</code> перекинет его к выбору группы, а затем, уже после подтверждения выбора, бот будет добавлен в группу с вызовом команды <code>/start id_викторины</code>.</p><p>Начнём разбираться с инлайн-режимом (не забудьте включить его у <a href=https://t.me/botfather>@BotFather</a>). Когда пользователь вызывает нашего бота через инлайн, показываем все созданные им викторины, плюс кнопку &ldquo;Создать новую&rdquo;. Если ничего нет, то только кнопку.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=05_inline_handler.py"></script><p>Очень важно выставить флаг <code>is_personal</code> равным <strong>True</strong> (ответ на запрос будет уникален для каждого Telegram ID) и указать небольшое значение параметра <code>cache_time</code>, чтобы кэш инлайн-ответов оперативно обновлялся по мере появления новых викторин.<br>Теперь при вызове бота через инлайн мы увидим наши сохранённые викторины, а при выборе одной из них — сообщение с кнопкой, по нажатию на которую нам предложат выбрать группу для отправки сообщения. Как только группа будет выбрана, в неё будет автоматически добавлен бот с сообщением вида <code>/start@имя_бота</code>. Но ничего не происходит! Сейчас разберёмся.</p><h2 id=отправляем-викторину-и-получаем-ответы>Отправляем викторину и получаем ответы</h2><p>Помните наш простой обработчик команды <code>/start</code>, возвращающий сообщение с кнопкой? Настало время переписать этот хэндлер. Первым делом, будем проверять, куда отправлено сообщение &ndash; в диалог с ботом или нет. Если в диалог, то всё остаётся по-прежнему: приветствие (на этот раз укажем, что викторина принудительно будет сделана неанонимной) и кнопка для создания викторины.</p><p>А вот если сообщение отправлено в группу, то применяем следующую логику: проверяем количество “слов” в сообщении. Одно всегда есть (команда <code>/start</code>), но может быть и второе, невидимое в интерфейсе приложения Telegram &ndash; параметр, переданный в качестве параметра <code>startgroup</code>, в нашем случае это ID викторины. Если второго слова нет (количество слов = 1), то показываем сообщение с предложением перейти в личку к боту с принудительным показом кнопки <code>/start</code>.</p><p>В случае, если второе слово есть, то считаем его идентификатором и пробуем отправить викторину в ту же группу. При этом мы, по сути, воспроизводим её [викторину] заново, просто от своего имени: повторяем вопрос, варианты ответов и отключаем анонимный режим, т.к. нам нужно знать, кто победитель.</p><p><strong>Очень важный момент</strong>: при отправке викторины, в объекте <code>Message</code> будет записан уже новый её идентификатор, который нужно подставить в наши словари. Далее по этому новому ID мы будем смотреть и считать ответы. Побочным эффектом такого подхода будет возможность использования конкретной викторины лишь однажды и в одном чате, если отправить сообщение из инлайна в другой чат, то зашитый в ссылке инлайн-кнопки ID будет недействительным.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=02_new_start_handler.py"></script><p>Далее необходимо научиться как-то обрабатывать новые ответы. В свежем обновлении API добавилось два новых типа обновлений (updates, т.е. входящие события): <code>PollAnswer</code> и просто <code>Poll</code>. Первый срабатывает при получении новых ответов в викторинах и опросах, в последнем случае ещё и при отзыве голоса (массив голосов от пользователя будет пустой). Второй срабатывает при изменении состояния опроса в целом, т.е. не только при получении новых ответов/голосов, но и при смене состояния &ldquo;открыт/закрыт&rdquo; и др. Опять-таки, в обучающих целях мы задействуем хэндлеры на оба типа событий.</p><p>Начнём с <code>PollAnswer</code>. Когда прилетает событие с новым ответом на викторину, прежде всего достаём её ID, по ней ищем автора во втором словаре. Если находим, то гуляем по всем викторинам этого пользователя и ищем совпадение по ID самой викторины, т.е. в точности обратное действие, только уже в первом словаре. Когда обнаружится нужная викторина, то проверяем, верный ответ или нет (сравниваем с <code>correct_option_id</code>), и если да, то записываем ID пользователя в список победителей. Если количество победителей при этом достигает двух, то останавливаем викторину.</p><p>Остановка викторины (метод <a href=https://core.telegram.org/bots/api#stoppoll>stop_poll( )</a>) вызовет срабатывание хэндлера на тип обновлений <code>Poll</code> с условием <code>is_closed is True</code>. Снова извлекаем нужный нам экземпляр класса <strong>Quiz</strong>, вытаскиваем ID победителей и вызываем метод <a href=https://core.telegram.org/bots/api#getchatmember>get_chat_member</a>, после чего, используя aiogram-ный вспомогательный метод <code>get_mention</code>, формируем ссылку на каждого из победителей в HTML-разметке и создаём поздравительное сообщение. Викторины у нас одноразовые, поэтому подчищаем за собой словари, дабы не раздувать объекты в памяти.</p><script type=application/javascript src="https://gist.github.com/MasterGroosha/2f8659f3623c6fe83c1f3167335e9c7f.js?file=03_poll_handlers.py"></script><p>Код готов. Закинем викторину в группу и попросим друзей правильно ответить, а сами ответим неправильно.
После первого правильного ответа:</p><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l13_2.png></center>
<center><i>2 ответа, только один правильный</i></center><p>После второго правильного ответа:</p><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l13_3.png></center>
<center><i>3 ответа, 2 правильных, опрос закрыт</i></center><p>На этом всё! Если у вас возникли вопросы, не стесняйтесь задавать их в <a href=https://t.me/joinchat/ABtnIE7H7Q3TRRh8n8uNww>нашем чатике</a>, а если вы нашли ошибку/опечатку, либо есть чем дополнить материал, то добро пожаловать на <a href=https://github.com/MasterGroosha/telegram-tutorial/issues>GitHub</a> (ну, или всё так же в чате). Полный код урока можно найти <a href=https://github.com/MasterGroosha/telegram-tutorial/tree/master/lesson_13>здесь</a>.</p><p><a href=/telegram-tutorial/docs/lesson_12/ class=book-btn style=float:left>← Урок №12</a>
<a href=/telegram-tutorial/docs/lesson_14/ class=book-btn style=float:right>Урок №14 →</a></p></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><ul><li><a href=#введение>Введение</a></li><li><a href=#пятиминутка-ненависти-к-telebot-или-привет-aiogram>Пятиминутка ненависти к telebot или Привет, aiogram!</a></li><li><a href=#плацдарм-для-бота>Плацдарм для бота</a></li><li><a href=#запрашиваем-викторину-у-пользователя>Запрашиваем викторину у пользователя</a></li><li><a href=#сохраняем-и-предлагаем>Сохраняем и предлагаем</a></li><li><a href=#отправляем-викторину-и-получаем-ответы>Отправляем викторину и получаем ответы</a></li></ul></li></ul></nav></aside></main></body></html>