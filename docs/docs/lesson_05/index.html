<!doctype html><html lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Автопостинг в каналы"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:type" content="article"><meta property="og:description" content="Урок 5: Автопостинг в каналы"><meta property="og:url" content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_05/"><meta property="og:site_name" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png"><title>Урок 5: Автопостинг в каналы | Пишем ботов для Telegram на языке Python</title><link rel=manifest href=/telegram-tutorial/manifest.json><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon><link rel=stylesheet href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a></h2><ul><li class=book-section-flat><span>pyTelegramBotAPI</span><ul><li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/ class=active>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan (неактуально)</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></li><li class=book-section-flat><span>aiogram</span><ul><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></li></ul><ul><li><a href=/telegram-tutorial/posts/></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Урок 5</strong>
<label for=toc-control><img src=/telegram-tutorial/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#примечание-к-уроку>Примечание к уроку</a></li><li><a href=#описание>Описание</a></li><li><a href=#получаем-записи>Получаем записи</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1>Автопостинг в каналы</h1><p><h2 id=примечание-к-уроку>Примечание к уроку</h2><p>Сам текст написан в 2015-м. В начале 2017 года ВК начал требовать токен пользователя для вызова метода wall.get и многих других. Процесс получения токена для ВК не относится к теме учебника, следовательно, описан не будет. По ссылке <a href=https://vk.com/dev/manuals>https://vk.com/dev/manuals</a> любой желающий сможет найти документацию и описание процесса получения токена.</p><p>Где-то в 2018-2019 годах метод wall.get начал возвращать другую структуру ответа. Текст и код урока написаны для версии API v5.68</p><h2 id=описание>Описание</h2><p>Когда в Telegram появились <a href=https://telegram.org/blog/channels>каналы</a>, поначалу я к ним относился как к неудачной попытке клонировать Twitter. Сразу появились тупые канальчики с тупыми картиночками, что только усугубляло положение дел. Однако сейчас, спустя больше месяца <em>[этот текст был написан в 2015 – прим. авт.]</em>, моё мнение изменилось на диаметрально противоположное. Призванные заменить списки рассылки (ими вообще кто-то пользовался?), каналы дали возможность получать огромное количество контента, которым можно делиться, который можно сохранять.</p><p>В <a href=https://core.telegram.org/bots/faq#will-you-add-x-to-the-bot-api>Bot FAQ</a> есть интересная фраза: &ldquo;Мы будем внимательно смотреть на то, как люди пользуются ботами и развивать их в том направлении&rdquo;. С учетом того, что многие боты занимались именно рассылкой информации, каналы - это очень логичный и правильный шаг в развитии автоматизированных средств.<br>С точки зрения программиста, каналы решают сразу несколько ключевых проблем:</p><ol><li>Не надо зависеть от временных сбоев серверов Telegram при поллинге, т.к. нет входящих сообщений.</li><li>Анонимная рассылка сообщений (некоторые люди просили сделать возможность отправлять свои сообщения через &ldquo;безликого&rdquo; бота) максимально упростилась.</li><li>Не надо вести списки пользователей, которым нужно отправить информацию и внедрять паузы между отправкой сообщения по очереди всем, эту заботу берёт на себя сам Telegram.</li></ol><p>Лично я заметил, что некоторые паблики и группы ВКонтакте стали дублировать свои записи в каналы Telegram. Сегодня мы научимся делать то же самое без помощи каких-либо конструкторов или сторонних веб-сайтов. Чтобы не сильно заморачиваться, будем постить только ссылку на пост, превью к ней и так даст необходимый минимум информации о посте.</p><h2 id=получаем-записи>Получаем записи</h2><p>В качестве &ldquo;подопытного кролика&rdquo; выберем <a href=https://vk.com/team>официальный блог ВКонтакте</a>. Получать новые записи будем при помощи VK API.
Итак, сформируем ссылку, которая будет нам возвращать последние 10 записей от имени сообщества из группы VK Team: <a href="https://api.vk.com/method/wall.get?domain=team&count=10&filter=owner&access_token=token&v=5.68">https://api.vk.com/method/wall.get?domain=team&count=10&filter=owner&access_token=token&v=5.68</a>
Что здесь что? <code>domain</code> - короткое имя сообщества. Если его нет, то меняем <code>domain=xxx</code> на <code>owner_id=-yyy</code> (обратите внимание на минус перед числом, это важно). <code>count</code> - число выводимых записей. Чем дольше пауза между проверками и чем чаще в сообществе появляются записи, тем большее число нужно выставить, но не более 100. <code>filter=owner</code> просит сервер выводить записи только от имени группы, полезно, если стена открыта, <code>access_token</code> - это токен пользователя, который «дёргает» API от имени одного из приложений, а <code>v=5.68</code> – номер используемой версии API. При использовании более свежей версии (5.100 и выше), структура ответа будет другой, оставляю это для самостоятельного изучения. Давайте теперь создадим файл <code>bot.py</code>, в котором зададим основные константы и импорты:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:green># -*- coding: utf-8 -*-</span>

<span style=color:#00f>import</span> time
<span style=color:#00f>import</span> eventlet
<span style=color:#00f>import</span> requests
<span style=color:#00f>import</span> logging
<span style=color:#00f>import</span> telebot
<span style=color:#00f>from</span> time <span style=color:#00f>import</span> sleep

 <span style=color:green># Каждый раз получаем по 10 последних записей со стены</span>
URL_VK = <span style=color:#a31515>&#39;https://api.vk.com/method/wall.get?domain=team&amp;count=10&amp;filter=owner&amp;access_token=Ваш_токен_VK&amp;v=5.68&#39;</span>
FILENAME_VK = <span style=color:#a31515>&#39;last_known_id.txt&#39;</span>
BASE_POST_URL = <span style=color:#a31515>&#39;https://vk.com/wall-22822305_&#39;</span>

BOT_TOKEN = <span style=color:#a31515>&#39;токен бота, постящего в канал&#39;</span>
CHANNEL_NAME = <span style=color:#a31515>&#39;@канал&#39;</span>

bot = telebot.TeleBot(BOT_TOKEN)
</code></pre></div><p>Во-первых, не забудьте сделать нужного бота администратором канала, иначе фокус не удастся. Во-вторых, обратите внимание, что в импортах появилась библиотека <code>eventlet</code>, она поможет нам избежать проблем при получении записей из ВК. В-третьих, в указанный txt-файл будем записывать номер верхнего поста на момент проверки, я решил не заморачиваться с созданием key-value хранилищ, ради одного числа-то. В-четвёртых, в качестве параметра BASE_POST_URL указываем ссылку на любой пост из нашей группы без последнего числа.</p><p>Иногда ВК начинает дурить и не возвращает список постов за приемлемое время. В этом случае, нам нужно отвалиться по таймауту и пропустить проверку. Можно, конечно, попробовать ещё раз, но мы люди не настойчивые :)</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>def</span> get_data():
    timeout = eventlet.Timeout(10)
    <span style=color:#00f>try</span>:
        feed = requests.get(URL_VK)
        <span style=color:#00f>return</span> feed.json()
    <span style=color:#00f>except</span> eventlet.timeout.Timeout:
        logging.warning(<span style=color:#a31515>&#39;Got Timeout while retrieving VK JSON data. Cancelling...&#39;</span>)
        <span style=color:#00f>return</span> None
    <span style=color:#00f>finally</span>:
        timeout.cancel()
</code></pre></div><p>Суть простая: получилось - возвращаем объект с постами. Не получилось - возвращаем None. Теперь перейдем непосредственно к парсингу. Алгоритм будет такой:</p><ol><li>Открываем файл, хранящий последний известный номер верхнего поста.</li><li>Если метод get_data() вернул объект с записями, начинаем проходить по нему со второго элемента, т.к. первый - какое-то неизвестное мне рандомное число.</li><li>Если номер поста меньше или равен последнему известному - завершаем обход.</li><li>Проверяем наличие закрепленного поста. Если таковой есть, то передаем функции отправки сообщений все записи, кроме закрепленной. Иначе - просто передаем все.</li><li>У каждой проверяемой записи забираем ID, подставляем рядом с BASE_POST_URL и получаем полный ID записи.</li><li>Отправляем его в канал.</li><li>Как только обход завершился, берем номер первой (второй, если первая - закрепленная) записи и записываем в файл поверх старого значения.</li><li>Засыпаем или завершаемся.</li></ol><p>По поводу п.8: дополнительно предусмотрим в нашей программе два режима: в первом режиме скрипт постоянно работает, засыпая после каждой итерации на 4 минуты; во втором режиме скрипт просто завершает работу, что позволяет ставить его в <a href=https://ru.wikipedia.org/wiki/Cron>планировщик cron</a>. В определении режима нам поможет константная переменная SINGLE_RUN, которую надо не забыть указать где-нибудь вверху.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>def</span> send_new_posts(items, last_id):
    <span style=color:#00f>for</span> item <span style=color:#00f>in</span> items:
        <span style=color:#00f>if</span> item[<span style=color:#a31515>&#39;id&#39;</span>] &lt;= last_id:
            <span style=color:#00f>break</span>
        link = <span style=color:#a31515>&#39;{!s}{!s}&#39;</span>.format(BASE_POST_URL, item[<span style=color:#a31515>&#39;id&#39;</span>])
        bot.send_message(CHANNEL_NAME, link)
        <span style=color:green># Спим секунду, чтобы избежать разного рода ошибок и ограничений (на всякий случай!)</span>
        time.sleep(1)
    <span style=color:#00f>return</span>


<span style=color:#00f>def</span> check_new_posts_vk():
    <span style=color:green># Пишем текущее время начала</span>
    logging.info(<span style=color:#a31515>&#39;[VK] Started scanning for new posts&#39;</span>)
    <span style=color:#00f>with</span> open(FILENAME_VK, <span style=color:#a31515>&#39;rt&#39;</span>) <span style=color:#00f>as</span> file:
        last_id = int(file.read())
        <span style=color:#00f>if</span> last_id <span style=color:#00f>is</span> None:
            logging.error(<span style=color:#a31515>&#39;Could not read from storage. Skipped iteration.&#39;</span>)
            <span style=color:#00f>return</span>
        logging.info(<span style=color:#a31515>&#39;Last ID (VK) = {!s}&#39;</span>.format(last_id))
    <span style=color:#00f>try</span>:
        feed = get_data()
        <span style=color:green># Если ранее случился таймаут, пропускаем итерацию. Если всё нормально - парсим посты.</span>
        <span style=color:#00f>if</span> feed <span style=color:#00f>is</span> <span style=color:#00f>not</span> None:
            entries = feed[<span style=color:#a31515>&#39;response&#39;</span>][1:]
            <span style=color:#00f>try</span>:
                <span style=color:green># Если пост был закреплен, пропускаем его</span>
                tmp = entries[0][<span style=color:#a31515>&#39;is_pinned&#39;</span>]
                <span style=color:green># И запускаем отправку сообщений</span>
                send_new_posts(entries[1:], last_id)
            <span style=color:#00f>except</span> KeyError:
                send_new_posts(entries, last_id)
            <span style=color:green># Записываем новый last_id в файл.</span>
            <span style=color:#00f>with</span> open(FILENAME_VK, <span style=color:#a31515>&#39;wt&#39;</span>) <span style=color:#00f>as</span> file:
                <span style=color:#00f>try</span>:
                    tmp = entries[0][<span style=color:#a31515>&#39;is_pinned&#39;</span>]
                    <span style=color:green># Если первый пост - закрепленный, то сохраняем ID второго</span>
                    file.write(str(entries[1][<span style=color:#a31515>&#39;id&#39;</span>]))
                    logging.info(<span style=color:#a31515>&#39;New last_id (VK) is {!s}&#39;</span>.format((entries[1][<span style=color:#a31515>&#39;id&#39;</span>])))
                <span style=color:#00f>except</span> KeyError:
                    file.write(str(entries[0][<span style=color:#a31515>&#39;id&#39;</span>]))
                    logging.info(<span style=color:#a31515>&#39;New last_id (VK) is {!s}&#39;</span>.format((entries[0][<span style=color:#a31515>&#39;id&#39;</span>])))
    <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> ex:
        logging.error(<span style=color:#a31515>&#39;Exception of type {!s} in check_new_post(): {!s}&#39;</span>.format(type(ex).__name__, str(ex)))
        <span style=color:#00f>pass</span>
    logging.info(<span style=color:#a31515>&#39;[VK] Finished scanning&#39;</span>)
    <span style=color:#00f>return</span>
</code></pre></div><p>Осталось дело за малым - написать логику запуска всего процесса и инициализировать логгер, который будет писать в текстовый файлик обо всех событиях в жизни бота:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>if</span> __name__ == <span style=color:#a31515>&#39;__main__&#39;</span>:
    <span style=color:green># Избавляемся от спама в логах от библиотеки requests</span>
    logging.getLogger(<span style=color:#a31515>&#39;requests&#39;</span>).setLevel(logging.CRITICAL)
    <span style=color:green># Настраиваем наш логгер</span>
    logging.basicConfig(format=<span style=color:#a31515>&#39;[</span><span style=color:#a31515>%(asctime)s</span><span style=color:#a31515>] </span><span style=color:#a31515>%(filename)s</span><span style=color:#a31515>:</span><span style=color:#a31515>%(lineno)d</span><span style=color:#a31515> </span><span style=color:#a31515>%(levelname)s</span><span style=color:#a31515> - </span><span style=color:#a31515>%(message)s</span><span style=color:#a31515>&#39;</span>, level=logging.INFO,
                        filename=<span style=color:#a31515>&#39;bot_log.log&#39;</span>, datefmt=<span style=color:#a31515>&#39;</span><span style=color:#a31515>%d</span><span style=color:#a31515>.%m.%Y %H:%M:%S&#39;</span>)
    <span style=color:#00f>if</span> <span style=color:#00f>not</span> SINGLE_RUN:
        <span style=color:#00f>while</span> True:
            check_new_posts_vk()
            <span style=color:green># Пауза в 4 минуты перед повторной проверкой</span>
            logging.info(<span style=color:#a31515>&#39;[App] Script went to sleep.&#39;</span>)
            time.sleep(60 * 4)
    <span style=color:#00f>else</span>:
        check_new_posts_vk()
    logging.info(<span style=color:#a31515>&#39;[App] Script exited.</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#39;</span>)
</code></pre></div><p>Перед запуском бота, создадим вручную файл <code>last_known_id.txt</code> и впишем в него один из последних числовых ID, в моём случае это было чудесное число 1893. После включения бота, в зависимости от значения SINGLE_RUN, он будет либо постоянно работать, проверяя каждые 4 минуты на наличие новых постов, либо завершится после окончания первой проверки. Для себя я выбрал второй вариант, добавив скрипт в cron.</p><p>На сегодня всё, теперь вы можете легко и просто настроить автопостинг записей практически из любой группы ВК в свой канал.</p><p><a href=/telegram-tutorial/docs/lesson_04/ class=book-btn style=float:left>← Урок №4</a>
<a href=/telegram-tutorial/docs/lesson_06/ class=book-btn style=float:right>Урок №6 →</a></p></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><ul><li><a href=#примечание-к-уроку>Примечание к уроку</a></li><li><a href=#описание>Описание</a></li><li><a href=#получаем-записи>Получаем записи</a></li></ul></li></ul></nav></aside></main></body></html>