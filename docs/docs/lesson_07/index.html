<!doctype html><html lang=ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Встраиваемые боты (Inline)"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:type" content="article"><meta property="og:description" content="Урок 7: Встраиваемые боты (Inline)"><meta property="og:url" content="https://mastergroosha.github.io/telegram-tutorial/docs/lesson_07/"><meta property="og:site_name" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://mastergroosha.github.io/telegram-tutorial/bot_logo.png"><title>Урок 7: Встраиваемые боты (Inline) | Пишем ботов для Telegram на языке Python</title><link rel=manifest href=/telegram-tutorial/manifest.json><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon><link rel=stylesheet href=/telegram-tutorial/book.min.6df681b0bb21155cba49f6078e3559216772d8e03e780d240c73ea21817ed5e5.css integrity="sha256-bfaBsLshFVy6SfYHjjVZIWdy2OA+eA0kDHPqIYF+1eU="></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/telegram-tutorial><span>Пишем ботов для Telegram на языке Python</span></a></h2><ul><li class=book-section-flat><span>pyTelegramBotAPI</span><ul><li><a href=/telegram-tutorial/docs/pyTelegramBotAPI/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. «Угадай мелодию». Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. «Угадай мелодию». Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan (неактуально)</a></li><li><a href=/telegram-tutorial/docs/lesson_07/ class=active>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></li><li class=book-section-flat><span>aiogram</span><ul><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></li></ul><ul><li><a href=/telegram-tutorial/posts/></a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Урок 7</strong>
<label for=toc-control><img src=/telegram-tutorial/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#-важно>⚠️ Важно!</a></li><li><a href=#введение>Введение</a></li><li><a href=#простой-инлайн-бот>Простой инлайн-бот</a></li><li><a href=#дизайн-и-подсказки>Дизайн и подсказки</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1>Встраиваемые боты (Inline)</h1><p><h2 id=-важно>⚠️ Важно!</h2><p>Код, приведённый здесь, актуален для первой версии Bot API. Пожалуйста, откройте <a href=/telegram-tutorial/docs/lesson_08/>урок 8</a>, чтобы узнать о важных изменениях.</p><h2 id=введение>Введение</h2><p>4 января 2016 года разработчики Telegram выпустили большое дополнение к существующему BotAPI, заключающееся в появлении <a href=https://telegram.org/blog/inline-bots>встраиваемых ботов</a>.<br>К сожалению, не все до конца понимают, в чем их особенность. А вот в чем: если раньше для того, чтобы получить какую-либо информацию от бота и перекинуть её собеседнику нужно было открывать диалог с ботом, писать всякие команды, а потом пересылать ответ в нужный чат, то теперь всё стало быстрее и проще (для некоторых ситуаций): просто открываете нужный чат, вызываете бота, введя его ник в поле ввода сообщения, ставите пробел и пишете свой запрос. Бот отвечает на эти запросы в виде всплывающих подсказок, число и содержание которых зависит от того, что вы написали боту и от заложенного в него алгоритма. Если одна из подсказок удовлетворяет вашему запросу, нажимаете на неё и некоторое сообщение отправляется в тот чат, в котором вы находитесь.<br>Например, если вы хотите отправить своему собеседнику ссылку на статью о Telegram из русскоязычной Википедии, то достаточно ввести в поле ввода @wiki ru Telegram и подождать пару секунд. Результат представлен на рисунке:</p><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l7_1.jpg></center>
<center><i>Рис. 1. Как выглядят результаты запросов от встраиваемых ботов</i></center><p>Соответственно, если вы нажмете на одну из этих подсказок, то ссылка на соответствующую статью будет отправлена в текущий чат. Собственно, всё!<br>Помимо ссылок, при помощи Inline API можно отправлять фотографии, GIF-анимации, видеоанимации в формате Mpeg-4 и ссылки на видеозаписи, которые можно будет смотреть прямо в приложении.</p><p>Прежде, чем мы начнём писать своего встраиваемого бота, несколько слов о том, для чего <strong>НЕ</strong> надо их использовать и какие есть ограничения. Во-первых, такие боты нужны именно для подсказок, когда вы хотите чем-то поделиться, но вам нужна помощь бота. Вы же не помните все ссылки на те самые видео с котиками? А бот быстренько поможет его найти, чтобы вы поделились им в чатике. Во-вторых, существуют недокументированные ограничения по объемам отправляемой информации. Скажем, для текстов и ссылок нельзя отправлять элементы длиннее 300-400 символов (на самом деле, получается без проблем около двухсот, больше - с оговорками). На мой взгляд, это самый неприятный момент в API. Я давеча пытался прикрутить поиск цитат с сайта <a href=https://bash.im>Bash.im</a> из своей базы для одного из моих <a href=https://t.me/bashim_bot>ботов</a>. Увы, всё, чего удалось добиться, это отправка коротких цитат (примерно с твит размером) непосредственно текстом, длинных - через отправку ссылок на сам Баш.</p><h2 id=простой-инлайн-бот>Простой инлайн-бот</h2><p>Ну а теперь приступим к созданию нашего первого встраиваемого бота. Вообще говоря, никто не мешает добавить существующему Inline-возможности, но дабы не усложнять код, напишем отдельного.<br>Что же он будет уметь? Пусть на вход боту будут подаваться 2 числа, а он в подсказках будет предлагать основные математические действия: сложение, вычитание, умножение и деление. Да, пример надуманный, но как нельзя лучше показывает особенности Inline API.
В начале, зарегистрируем бота у <a href=https://t.me/botfather>@BotFather</a> (или воспользуемся имеющимся) для него вызовем команду /setinline.<br><strong>Внимание</strong>: после ввода этой команды и выбора бота нужно ввести подсказку, появляющуюся в поле ввода при вызове нашего бота в дальнейшем, иначе фокус не удастся.</p><p>Создадим файл исходного кода и добавим туда необходимые импорты и объект самого бота:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:green># -*- coding: utf-8 -*-</span>

<span style=color:#00f>import</span> telebot
<span style=color:#00f>import</span> re
<span style=color:#00f>from</span> telebot <span style=color:#00f>import</span> types

token = <span style=color:#a31515>&#39;ваш_токен&#39;</span>
bot = telebot.TeleBot(token)
</code></pre></div><p>Мы условились, что на вход будут подаваться 2 числа, поэтому нам нужно построить регулярное выражение, которое будет реагировать на корректный ввод. Оно очень простое:<br><code>digits_pattern = re.compile(r'^[0-9]+ [0-9]+$', re.MULTILINE)</code></p><p>А теперь самое главное - логика. Пока юзер пишет, Телеграм никак себя не проявляет, но как только он делает паузу, приложение считает, что это законченный ввод и отправляет его боту. Юзер дописал ещё пару символов и остановился? Окей, снова кидаем это боту. Соответственно, может сложиться ситуация, когда пользователь ввёл одно число и задумался. Наш парсер, попробовав сопоставить текст на наличие регулярного выражение, ругнётся и сотворит всякие нехорошие вещи, например, остановит весь скрипт (мы же помним, что Python - интерпретируемый язык, да?). Значит, надо ставить ловлю исключений:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>try</span>:
    matches = re.match(digits_pattern, query.query)
<span style=color:#00f>except</span> AttributeError <span style=color:#00f>as</span> ex:
    <span style=color:#00f>return</span>
</code></pre></div><p>Если условие выше отработало без ошибок, значит, мы получили два искомых числа. Теперь начинаются особенности Inline API. Каждая подсказка, присылаемая ботом, это объект с набором некоторых характеристик. Мы будем использовать объект типа &ldquo;Статья&rdquo;.
Согласно <a href=https://core.telegram.org/bots/api#inline-mode>документации</a>, обязательных параметров у такого объекта четыре: тип, уникальный идентификатор, заголовок и объект, который будет отправлен, чаще всего текст. По поводу типа можно не беспокоиться: используемая мной уже больше полугода библиотека <a href=https://github.com/eternnoir/pyTelegramBotAPI>pyTelegramBotAPI</a> подставит нужное значение сама. Уникальный идентификатор придется ставить самим и тут есть подвох: при использовании подгрузки (об этом в конце урока) идентификаторы должны быть уникальными у всех значений в одном большом запросе (т.е. у исходных результатов и всех подгружаемых в пределах одного запроса). Учтите это. Заголовок - очевидно. Отправляемый текст - то, что будет отправлено в текущий чат при нажатии на данную подсказку.<br>Есть ещё необязательный параметр &ldquo;описание&rdquo; (description). Так вот, описание != отправляемый текст. В подсказке может быть написано &ldquo;Наполеон - это торт&rdquo;, а в отправляемом тексте могут содержаться коды запуска ядерный ракет. Шутка, но смысл понятен.</p><p>Вооружившись этими знаниями и имея на руках два присланных пользователем числа, давайте создадим 4 объекта, каждый из которых отвечает за свою математическую операцию (на самом деле 5, т.к. учтем деление на ноль):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>num1, num2 = matches.group().split()
<span style=color:#00f>try</span>:
    m_sum = int(num1) + int(num2)
    r_sum = types.InlineQueryResultArticle(
            id=<span style=color:#a31515>&#39;1&#39;</span>, title=<span style=color:#a31515>&#34;Сумма&#34;</span>,
            <span style=color:green># Описание отображается в подсказке,</span>
            <span style=color:green># message_text - то, что будет отправлено в виде сообщения</span>
            description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_sum),
            input_message_content=types.InputTextMessageContent(
            message_text=<span style=color:#a31515>&#34;{!s} + {!s} = {!s}&#34;</span>.format(num1, num2, m_sum))
    )
    m_sub = int(num1) - int(num2)
    r_sub = types.InlineQueryResultArticle(
            id=<span style=color:#a31515>&#39;2&#39;</span>, title=<span style=color:#a31515>&#34;Разность&#34;</span>,
            description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_sub),
            input_message_content=types.InputTextMessageContent(
            message_text=<span style=color:#a31515>&#34;{!s} - {!s} = {!s}&#34;</span>.format(num1, num2, m_sub))
    )
    <span style=color:green># Учтем деление на ноль и подготовим 2 варианта развития событий</span>
    <span style=color:#00f>if</span> num2 <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#a31515>&#34;0&#34;</span>:
        m_div = int(num1) / int(num2)
        r_div = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;3&#39;</span>, title=<span style=color:#a31515>&#34;Частное&#34;</span>,
                description=<span style=color:#a31515>&#34;Результат: {0:.2f}&#34;</span>.format(m_div),
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;{0!s} / {1!s} = {2:.2f}&#34;</span>.format(num1, num2, m_div))
        )
    <span style=color:#00f>else</span>:
        r_div = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;3&#39;</span>, title=<span style=color:#a31515>&#34;Частное&#34;</span>, description=<span style=color:#a31515>&#34;На ноль делить нельзя!&#34;</span>,
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;Я нехороший человек и делю на ноль!&#34;</span>)
        )
    m_mul = int(num1) * int(num2)
    r_mul = types.InlineQueryResultArticle(
            id=<span style=color:#a31515>&#39;4&#39;</span>, title=<span style=color:#a31515>&#34;Произведение&#34;</span>,
            description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_mul),
            input_message_content=types.InputTextMessageContent(
            message_text=<span style=color:#a31515>&#34;{!s} * {!s} = {!s}&#34;</span>.format(num1, num2, m_mul))
    )
    bot.answer_inline_query(query.id, [r_sum, r_sub, r_div, r_mul])
<span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
    <span style=color:#00f>print</span>(<span style=color:#a31515>&#34;{!s}</span><span style=color:#a31515>\n</span><span style=color:#a31515>{!s}&#34;</span>.format(type(e), str(e)))
</code></pre></div><p>Полагаю, тут ничего сверхсложного нет. Вызывает интерес только последняя строка, а именно метод <code>answer_inline_query</code>. У него обязательных параметров два: уникальный идентификатор запроса (его получает хэндлер, так что про него забываем) и массив ответов. Загоняем теперь предыдущие два куска кода в одну функцию, обернутую хэндлером:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@bot.inline_handler(func=<span style=color:#00f>lambda</span> query: len(query.query) &gt; 0)
<span style=color:#00f>def</span> query_text(query):
    (<span>тут</span> <span>два</span> <span>куска</span> <span>кода</span>, <span>приведённых</span> <span>выше</span>)
</code></pre></div><p>И можно запускать! Введём в любом чате, кроме секретного, ник нашего бота и два числа. Смотрим на подсказку:</p><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l7_2.jpg></center>
<center><i>Рис. 2. Результат работы бота</i></center><h2 id=дизайн-и-подсказки>Дизайн и подсказки</h2><p>В принципе, правильно, но как-то не наглядно. Да и не очень понятно для нового пользователя, как, что и зачем.<br>А давайте учтем ситуацию, когда пользователь ввёл только ник бота, и покажем ему подсказку:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@bot.inline_handler(func=<span style=color:#00f>lambda</span> query: len(query.query) <span style=color:#00f>is</span> 0)
<span style=color:#00f>def</span> empty_query(query):
    hint = <span style=color:#a31515>&#34;Введите ровно 2 числа и получите результат!&#34;</span>
    <span style=color:#00f>try</span>:
        r = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;1&#39;</span>,
                parse_mode=<span style=color:#a31515>&#39;Markdown&#39;</span>,
                title=<span style=color:#a31515>&#34;Бот </span><span style=color:#a31515>\&#34;</span><span style=color:#a31515>Математика</span><span style=color:#a31515>\&#34;</span><span style=color:#a31515>&#34;</span>,
                description=hint,
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;Эх, зря я не ввёл 2 числа :(&#34;</span>)
        )
        bot.answer_inline_query(query.id, [r])
    <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
        <span style=color:#00f>print</span>(e)
</code></pre></div><p>Уже лучше, но всё равно не очень наглядно. А давайте добавим превью для каждой подсказки, чтобы слева была иконка соответствующей операции, и, заодно, сделаем превью при делении на ноль кликабельным, отправляя пользователя на <a href=https://ru.wikipedia.org/wiki/%d0%94%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5_%d0%bd%d0%b0_%d0%bd%d0%be%d0%bb%d1%8c>эту страницу Википедии</a>.<br>Во-первых, закачаем на какой-нибудь бесплатный хостинг иконки с нашими математическими операциями (сгенерировал в <a href=https://www.syncfusion.com/downloads/metrostudio>Metro Studio</a>, размер каждой 48х48 px):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>plus_icon = <span style=color:#a31515>&#34;https://pp.vk.me/c627626/v627626512/2a627/7dlh4RRhd24.jpg&#34;</span>
minus_icon = <span style=color:#a31515>&#34;https://pp.vk.me/c627626/v627626512/2a635/ILYe7N2n8Zo.jpg&#34;</span>
divide_icon = <span style=color:#a31515>&#34;https://pp.vk.me/c627626/v627626512/2a620/oAvUk7Awps0.jpg&#34;</span>
multiply_icon = <span style=color:#a31515>&#34;https://pp.vk.me/c627626/v627626512/2a62e/xqnPMigaP5c.jpg&#34;</span>
error_icon = <span style=color:#a31515>&#34;https://pp.vk.me/c627626/v627626512/2a67a/ZvTeGq6Mf88.jpg&#34;</span>
</code></pre></div><p>Во-вторых, отредактируем функцию <code>query_text</code>, добавив к каждому объекту типа &ldquo;Статья&rdquo; иконку, а для деления на ноль - свою иконку и ссылку:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>@bot.inline_handler(func=<span style=color:#00f>lambda</span> query: len(query.query) &gt; 0)
<span style=color:#00f>def</span> query_text(query):
    <span style=color:#00f>try</span>:
        matches = re.match(digits_pattern, query.query)
    <span style=color:green># Вылавливаем ошибку, если вдруг юзер ввёл чушь</span>
    <span style=color:green># или задумался после ввода первого числа</span>
    <span style=color:#00f>except</span> AttributeError <span style=color:#00f>as</span> ex:
        <span style=color:#00f>return</span>
    <span style=color:green># В этом месте мы уже уверены, что всё хорошо,</span>
    <span style=color:green># поэтому достаем числа</span>
    num1, num2 = matches.group().split()
    <span style=color:#00f>try</span>:
        m_sum = int(num1) + int(num2)
        r_sum = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;1&#39;</span>, title=<span style=color:#a31515>&#34;Сумма&#34;</span>,
                <span style=color:green># Описание отображается в подсказке,</span>
                <span style=color:green># message_text - то, что будет отправлено в виде сообщения</span>
                description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_sum),
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;{!s} + {!s} = {!s}&#34;</span>.format(num1, num2, m_sum)),
                <span style=color:green># Указываем ссылку на превью и его размеры</span>
                thumb_url=plus_icon, thumb_width=48, thumb_height=48
        )
        m_sub = int(num1) - int(num2)
        r_sub = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;2&#39;</span>, title=<span style=color:#a31515>&#34;Разность&#34;</span>,
                description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_sub),
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;{!s} - {!s} = {!s}&#34;</span>.format(num1, num2, m_sub)),
                thumb_url=minus_icon, thumb_width=48, thumb_height=48
        )
        <span style=color:green># Учтем деление на ноль и подготовим 2 варианта развития событий</span>
        <span style=color:#00f>if</span> num2 <span style=color:#00f>is</span> <span style=color:#00f>not</span> <span style=color:#a31515>&#34;0&#34;</span>:
            m_div = int(num1) / int(num2)
            r_div = types.InlineQueryResultArticle(
                    id=<span style=color:#a31515>&#39;3&#39;</span>, title=<span style=color:#a31515>&#34;Частное&#34;</span>,
                    description=<span style=color:#a31515>&#34;Результат: {0:.2f}&#34;</span>.format(m_div),
                    input_message_content=types.InputTextMessageContent(
                    message_text=<span style=color:#a31515>&#34;{0!s} / {1!s} = {2:.2f}&#34;</span>.format(num1, num2, m_div)),
                    thumb_url=divide_icon, thumb_width=48, thumb_height=48
            )
        <span style=color:#00f>else</span>:
            r_div = types.InlineQueryResultArticle(
                    id=<span style=color:#a31515>&#39;3&#39;</span>, title=<span style=color:#a31515>&#34;Частное&#34;</span>, description=<span style=color:#a31515>&#34;На ноль делить нельзя!&#34;</span>,
                    input_message_content=types.InputTextMessageContent(
                    message_text=<span style=color:#a31515>&#34;Я нехороший человек и делю на ноль!&#34;</span>),
                    thumb_url=error_icon, thumb_width=48, thumb_height=48,
                    <span style=color:green># Сделаем превью кликабельным, по нажатию юзера направят по ссылке</span>
                    url=<span style=color:#a31515>&#34;https://ru.wikipedia.org/wiki/%D0</span><span style=color:#a31515>%94%</span><span style=color:#a31515>D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BD%D0%B0_%D0%BD%D0%BE%D0%BB%D1%8C&#34;</span>,
                    disable_web_page_preview=True,
                    <span style=color:green># Не будем показывать URL в подсказке</span>
                    hide_url=True
            )
        m_mul = int(num1) * int(num2)
        r_mul = types.InlineQueryResultArticle(
                id=<span style=color:#a31515>&#39;4&#39;</span>, title=<span style=color:#a31515>&#34;Произведение&#34;</span>,
                description=<span style=color:#a31515>&#34;Результат: {!s}&#34;</span>.format(m_mul),
                input_message_content=types.InputTextMessageContent(
                message_text=<span style=color:#a31515>&#34;{!s} * {!s} = {!s}&#34;</span>.format(num1, num2, m_mul)),
                thumb_url=multiply_icon, thumb_width=48, thumb_height=48
        )
        <span style=color:green># В нашем случае, результаты вычислений не изменятся даже через долгие годы, НО!</span>
        <span style=color:green># если где-то допущена ошибка и cache_time уже выставлен большим, то это уже никак не исправить (наверное)</span>
        <span style=color:green># Для справки: 2147483646 секунд - это 68 с копейками лет :)</span>
        bot.answer_inline_query(query.id, [r_sum, r_sub, r_div, r_mul], cache_time=2147483646)
    <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
        <span style=color:#00f>print</span>(<span style=color:#a31515>&#34;{!s}</span><span style=color:#a31515>\n</span><span style=color:#a31515>{!s}&#34;</span>.format(type(e), str(e)))
</code></pre></div><p>Обратите снова внимание на функцию <code>answer_inline_query</code>, в ней я добавил аргумент <code>cache_time</code>. Значит он именно то, что первым приходит в голову — устанавливает время, на которое результат будет закэширован, чтобы лишний раз не дергать бота. Сейчас на моей стороне тот факт, что математика - фундаментальная наука, и за те 68 с копейками лет, что указаны у меня в аргументе <code>cache_time</code>, результат операций не изменится. Но! Выше на рис. 2 у меня слева от подсказок нет ничего, никаких картинок. И да, в течение 68 с лишним лет конкретно для данного запроса так и будет. Поэтому трижды подумайте, прежде чем установите большое время кэширования. Для каких-то динамических результатов, например, для подсказки при нулевом запросе, вполне достаточно времени 86400 (1 сутки). По умолчанию, кстати, вообще всего 300 секунд, т.е. 5 минут.</p><p>Теперь наши результаты выглядят куда симпатичнее:</p><div class="book-columns flex flex-wrap"><div class="flex-even markdown-inner"><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l7_3.jpg></center>
<center><i></i></center></div><div class="flex-even markdown-inner"><center><img src=https://mastergroosha.github.io/telegram-tutorial//images/l7_4.jpg></center>
<center><i></i></center></div></div><p>Прекрасно! Мы написали своего первого встраиваемого бота! Но&mldr;
Но есть ещё такая штука, как <code>offset</code>. Вообще говоря, это нужно для постепенной подгрузки новых результатов. Например, пользователь запрашивает видео с котиками, бот возвращает пять штук. Как только юзер долистывает до конца, бот запрашивает у своего источника ещё пять, а Telegram дописывает их к уже имеющимся. В итоге, уже 10 вариантов и так далее. В одном из своих ботов я сделал так: запрашиваю из БД 5 записей с <code>offset</code> равным нулю. При отправке их пользователю, я устанавливаю в функции <code>answer_inline_query</code> параметр <code>next_offset</code> в значение 5 (строковый параметр, если что). Если юзер долистал до конца, то боту придет запрос с этим же текстом, но с значением <code>offset</code> как раз 5, поэтому в следующий раз я из БД запрошу уже следующие пять записей, прибавлю ещё пятерку к текущему значению, получая 10 и снова верну пользователю значения. Как только у меня закончились соответствующие запросу данные в базе, отправляю пустую строку в качестве аргумента <code>next_offset</code>. В общем, всё выглядит примерно так (бОльшая часть кода вырезана для упрощения понимания):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00f>def</span> query_text(query):
    offset = int(query.offset) <span style=color:#00f>if</span> query.offset <span style=color:#00f>else</span> 0
    <span style=color:#00f>with</span> sqlite3.connect(<span style=color:#a31515>&#39;quotes.db&#39;</span>) <span style=color:#00f>as</span> connection:
        cursor = connection.cursor()
        <span style=color:green># Тут используется SQLite Full-Text Search, не пугайтесь</span>
        quotes = cursor.execute(<span style=color:#a31515>&#34;SELECT num, text FROM quotes WHERE quotes.id IN (SELECT rowid FROM fts WHERE text MATCH ?) LIMIT 5 OFFSET ?&#34;</span>, (query.query, offset,)).fetchall()
    <span style=color:#00f>if</span> len(quotes) <span style=color:#00f>is</span> 0:
        <span style=color:#00f>try</span>:
            result = types.InlineQueryResultArticle(id=<span style=color:#a31515>&#39;1&#39;</span>,
                                           title=(<span>заголовок</span>),
                                           description=(<span>описание</span>),
                                           input_message_content=types.InputTextMessageContent(
                                           message_text=<span style=color:#a31515>&#34;(текст)&#34;</span>))
            bot.answer_inline_query(query.id, [result])
        <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
            <span style=color:#00f>print</span>(e)
        <span style=color:#00f>return</span>
    results_array = []
    <span style=color:#00f>try</span>:
        m_next_offset = str(offset + 5) <span style=color:#00f>if</span> len(quotes) == 5 <span style=color:#00f>else</span> None
        <span style=color:#00f>for</span> index, quote <span style=color:#00f>in</span> enumerate(quotes):
            <span style=color:#00f>try</span>:
                <span style=color:green># При использовании подгрузки, ID должны быть уникальными в пределах всей большой пачки!</span>
                results_array.append(types.InlineQueryResultArticle(id=str(offset + index),
                                           title=(<span>заголовок</span>),
                                           description=(<span>описание</span>),
                                           input_message_content=types.InputTextMessageContent(
                                           message_text=(<span>текст</span>)),
                                           )
                                    )
            <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
                <span style=color:#00f>print</span>(e)
        <span style=color:green># устанавливаем новый offset или сбрасываем, если в БД закончились релевантные записи</span>
        bot.answer_inline_query(query.id, results_array, next_offset=m_next_offset <span style=color:#00f>if</span> m_next_offset <span style=color:#00f>else</span> <span style=color:#a31515>&#34;&#34;</span>)
    <span style=color:#00f>except</span> Exception <span style=color:#00f>as</span> e:
        <span style=color:#00f>print</span>(e)
</code></pre></div><p>На этом урок действительно закончен.</p><p><a href=/telegram-tutorial/docs/lesson_06/ class=book-btn style=float:left>← Урок №6</a>
<a href=/telegram-tutorial/docs/lesson_08/ class=book-btn style=float:right>Урок №8 →</a></p></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><ul><li><a href=#-важно>⚠️ Важно!</a></li><li><a href=#введение>Введение</a></li><li><a href=#простой-инлайн-бот>Простой инлайн-бот</a></li><li><a href=#дизайн-и-подсказки>Дизайн и подсказки</a></li></ul></li></ul></nav></aside></main></body></html>