<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Урок 8. Bot API v2: Кнопки и редактирование сообщений
  
 | Пишем ботов для Telegram на языке Python</title>



<link rel="stylesheet" href="/test-web/css/override.css">
<link rel="stylesheet" href="/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css">

<meta property="og:title" content="Пишем ботов для Telegram на языке Python" />
<meta property="og:image" content="https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828" />
<meta property="og:description" content="Учебник для ботописателей" />



<link rel="icon" href="/telegram-tutorial/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://mastergroosha.github.io/telegram-tutorial/">Пишем ботов для Telegram на языке Python</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2ftelegram-tutorial\2f docs\2flesson_08\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/telegram-tutorial/docs/lesson_01/">Урок 1. Введение, простой echo-бот</a></li>
<li><a href="/telegram-tutorial/docs/lesson_02/">Урок 2. “Угадай мелодию”. Подготовка</a></li>
<li><a href="/telegram-tutorial/docs/lesson_03/">Урок 3. “Угадай мелодию”. Завершаем бота</a></li>
<li><a href="/telegram-tutorial/docs/lesson_04/">Урок 4. Вебхуки</a></li>
<li><a href="/telegram-tutorial/docs/lesson_05/">Урок 5. Автопостинг в каналы</a></li>
<li><a href="/telegram-tutorial/docs/lesson_06/">Урок 6. Собираем аналитику при помощи Botan</a></li>
<li><a href="/telegram-tutorial/docs/lesson_07/">Урок 7. Встраиваемые боты (Inline)</a></li>
<li><a href="/telegram-tutorial/docs/lesson_08/">Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li>
<li><a href="/telegram-tutorial/docs/lesson_09/">Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li>
<li><a href="/telegram-tutorial/docs/lesson_10/">Урок 10. Bot API v3. Автоматизируем работу в группах</a></li>
<li><a href="/telegram-tutorial/docs/lesson_11/">Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li>
<li><a href="/telegram-tutorial/docs/lesson_12/">Урок 12. Запускаем несколько ботов на одном сервере</a></li>
</ul>





</nav>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/telegram-tutorial/svg/menu.svg" alt="Menu" />
  </label>
</header>

      
<header class="markdown">
  <h1>Урок 8. Bot API v2: Кнопки и редактирование сообщений</h1>
</header>
<article class="markdown">

<h2 id="введение">Введение</h2>

<p>В начале апреля 2016 года <a href="https://telegram.org/blog/bots-2-0">вышло</a> первое по-настоящему крупное обновление API для ботов. Изменений довольно много, поэтому материал я разобью на несколько частей. Сегодня поговорим об inline-кнопках и редактировании сообщений, а затем обсудим новые инлайн-режимы вместе со специальными кнопками для отправки геолокации и номера телефона.</p>

<h2 id="новые-возможности">Новые возможности</h2>

<p>Начнём с двух важных изменений:<br />
1) Каждая кнопка, будь то обычная или инлайн, это теперь самостоятельный объект <code>KeyboardButton</code> или <code>InlineKeyboardButton</code>, не забудьте обновить своих ботов!<br />
2) В Inline-режиме все текстовые поля теперь представлены отдельными объектами <code>InputMessageContent</code>, которые, в свою очередь могут быть аж 4-х типов (подробности <a href="https://core.telegram.org/bots/api#inputmessagecontent">тут</a>).</p>

<h3 id="url-кнопки">URL-кнопки</h3>

<p>Итак, <strong>инлайн-кнопки</strong>. Что это такое? Это специальные объекты, которые &ldquo;цепляются&rdquo; к конкретным сообщениям и распространяют своё действие, в общем случае, только на них. Делятся такие кнопки на три типа: URL-кнопки, Callback-кнопки и Switch-кнопки.
Самыми простыми являются кнопки-ссылки (URL). Как видно из названия, их цель - просто перекидывать пользователей по определенным веб-адресам. Давайте сразу напишем обработчик, который будет на любое сообщение отвечать каким-либо текстом и предложением перейти, например, на Яндекс.</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none">@bot.message_handler(content_types=[&#34;text&#34;])
def default_test(message):
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton(text=&#34;Перейти на Яндекс&#34;, url=&#34;https://ya.ru&#34;)
    keyboard.add(url_button)
    bot.send_message(message.chat.id, &#34;Привет! Нажми на кнопку и перейди в поисковик.&#34;, reply_markup=keyboard)</code></pre></div>

<p>Инлайн-клавиатура представляет собой объект <code>InlineKeyboardMarkup</code>, а каждая инлайн-кнопка – это объект <code>InlineKeyboardButton</code>. Чтобы получилась URL-кнопка, нужно указать значения параметров <code>text</code> (текст на кнопке) и <code>url</code> (валидный веб-адрес). В результате бот пришлет нам такое сообщение (см. рис.). В целях обеспечения безопасности, перед переходом по URL-кнопкам появляется всплывающее окно, в котором видна ссылка целиком.</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l8_1.png" alt="URL-кнопка"/>
    <figcaption>
         <h4><i>URL-кнопка</i></h4>
    </figcaption>
</figure>
</center></p>

<h3 id="callback-кнопки-и-редактирование-сообщений">Callback-кнопки и редактирование сообщений</h3>

<p>Прежде, чем мы перейдем к другим кнопкам, давайте познакомимся с функциями редактирования сообщений, коих тоже три: <code>editMessageText</code> (редактирование текста), <code>editMessageCaption</code> (редактирование подписи к медиа) и <code>editMessageReplyMarkup</code> (редактирование инлайн-клавиатуры). В рамках этого урока рассмотрим только первую функцию, остальные работают аналогично и предлагаются для самостоятельного изучения.<br />
Чтобы отредактировать сообщение, нам надо знать, про какое именно идёт речь. В случае, если оно было отправлено самим ботом, идентификаторами служит связка <code>chat_id</code> + <code>message_id</code>. Но если сообщение было отправлено в инлайн-режиме, то ориентироваться надо по параметру <code>inline_message_id</code>.</p>

<p>И вот теперь вернемся к нашим <del>баранам</del> кнопкам. На очереди – <strong>Callback</strong>. Это, на мой взгляд, самая крутая фича нового обновления. Колбэк-кнопки позволяют выполнять произвольные действия по их нажатию. Всё зависит от того, какие параметры каждая кнопка в себе несёт. Соответственно, все нажатия будут приводить к отправке боту объекта <code>CallbackQuery</code>, содержащему поле <code>data</code>, в котором написана некоторая строка, заложенная в кнопку, а также либо объект <code>Message</code>, если сообщение отправлено ботом в обычном режиме, либо поле <code>inline_message_id</code>, если сообщение отправлено в инлайн-режиме.</p>

<p>Приведу пример, после которого все вопросы должны отпасть: пусть, например, если сообщение отправлено ботом в обычном режиме, то нажатие на кнопку заменит текст сообщения на &ldquo;Пыщь&rdquo;, если в инлайн – то &ldquo;Бдыщь&rdquo;. При этом в обоих случаях значение <code>callback_data</code> будет равно <code>test</code>. Что для этого нужно сделать: во-первых, написать простейший хэндлер для всех входящих сообщений, во-вторых, написать простейший хэндлер для инлайн-сообщений, в-третьих, написать простейший хэндлер для колбэка, который определит, из какого режима пришло сообщение.</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none"># Обычный режим
@bot.message_handler(content_types=[&#34;text&#34;])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    callback_button = types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, callback_data=&#34;test&#34;)
    keyboard.add(callback_button)
    bot.send_message(message.chat.id, &#34;Я – сообщение из обычного режима&#34;, reply_markup=keyboard)


# Инлайн-режим с непустым запросом
@bot.inline_handler(lambda query: len(query.query) &gt; 0)
def query_text(query):
    kb = types.InlineKeyboardMarkup()
    # Добавляем колбэк-кнопку с содержимым &#34;test&#34;
    kb.add(types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, callback_data=&#34;test&#34;))
    results = []
    single_msg = types.InlineQueryResultArticle(
        id=&#34;1&#34;, title=&#34;Press me&#34;,
        input_message_content=types.InputTextMessageContent(message_text=&#34;Я – сообщение из инлайн-режима&#34;),
        reply_markup=kb
    )
    results.append(single_msg)
    bot.answer_inline_query(query.id, results)


# В большинстве случаев целесообразно разбить этот хэндлер на несколько маленьких
@bot.callback_query_handler(func=lambda call: True)
def callback_inline(call):
    # Если сообщение из чата с ботом
    if call.message:
        if call.data == &#34;test&#34;:
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=&#34;Пыщь&#34;)
    # Если сообщение из инлайн-режима
    elif call.inline_message_id:
        if call.data == &#34;test&#34;:
            bot.edit_message_text(inline_message_id=call.inline_message_id, text=&#34;Бдыщь&#34;)

if __name__ == &#39;__main__&#39;:
    bot.polling(none_stop=True)</code></pre></div>

<p>Запускаем бота, отправляем инлайн-сообщение, которое, в свою очередь, вызовет обычное:</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l8_2.png" alt=""/>
    <figcaption>
         <h4><i></i></h4>
    </figcaption>
</figure>
</center></p>

<p>Нажмем на обе кнопки, результат правильный:</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l8_3.png" alt="После проверки"/>
    <figcaption>
         <h4><i>После проверки</i></h4>
    </figcaption>
</figure>
</center></p>

<p>Таким образом, callback-кнопки – это очень мощный инструмент для взаимодействия пользователей с ботом, а редактирование сообщений дополнительно помогает в этом.
Более того, нажатие на колбэк-кнопку может дополнительно тригернуть либо уведомление в верхней части экрана, либо всплывающее окно. Покажу первый вариант. Пускай помимо изменения сообщения на &ldquo;Пыщь&rdquo;, аналогичное слово показывается уведомлением. Для этого перепишем первое if-условие в хендлере колбэков:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none">if call.message:
    if call.data == &#34;test&#34;:
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=&#34;Пыщь&#34;)
        bot.answer_callback_query(callback_query_id=call.id, show_alert=False, text=&#34;Пыщь!&#34;)</code></pre></div>

<p>Результат – на скриншоте. Попробуйте, кстати, изменить аргумент <code>show_alert</code> на <code>True</code> и посмотрите, что получится.</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l8_4.png" alt="Всплывающее уведомление"/>
    <figcaption>
         <h4><i>Всплывающее уведомление</i></h4>
    </figcaption>
</figure>
</center></p>

<h3 id="switch-кнопки">Switch-кнопки</h3>

<p>Наконец, остался последний тип кнопок - <strong>Switch</strong> (переключатель). Они нужны, чаще всего, для обучения пользователей работе с ботом в инлайн-режиме. Чтобы активировать сделать кнопку такого типа, нужно указать аргумент <code>switch_inline_query</code> либо пустой, либо с каким-либо текстом. В последнем случае этот текст будет сразу подставлен в поле ввода, например, для показа демонстрации инлайна. Как вообще работает такая кнопка? При нажатии на неё Telegram предложит выбрать чат, после чего подставит в поле ввода ник вашего бота и (если есть), текст, указанный вами в аргументе <code>switch_inline_query</code>. Давайте попробуем так сделать. Добавим кнопку, которая будет перенаправлять пользователя в какой-либо чат и предлагать в инлайн-режиме запрос &ldquo;Telegram&rdquo;. Код всего хендлера выглядит вот так:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none">@bot.message_handler(content_types=[&#34;text&#34;])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    switch_button = types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, switch_inline_query=&#34;Telegram&#34;)
    keyboard.add(switch_button)
    bot.send_message(message.chat.id, &#34;Я – сообщение из обычного режима&#34;, reply_markup=keyboard)</code></pre></div>

<p>Теперь, если мы нажмем на кнопку и выберем чат, вот что получится:</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l8_5.png" alt="Результат"/>
    <figcaption>
         <h4><i>Результат</i></h4>
    </figcaption>
</figure>
</center></p>

<p>Итак, в этом уроке мы познакомились с новыми кнопками в Telegram Bot API, научились <del>переписывать историю</del> редактировать сообщения и отправлять небольшие уведомления по нажатию. В следующий раз продолжим изучать новые возможности для ботов.
А исходники к этому уроку можно найти в <a href="https://github.com/MasterGroosha/telegram-tutorial">этом репозитории</a></p>

<p>



  

<a  href="/telegram-tutorial/docs/lesson_07/"   class="book-btn" style="float: left;">← Урок №7</a>





  

<a  href="/telegram-tutorial/docs/lesson_09/"   class="book-btn" style="float: right;">Урок №9 →</a>
</p>
</article>

      

      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#введение">Введение</a></li>
<li><a href="#новые-возможности">Новые возможности</a>
<ul>
<li><a href="#url-кнопки">URL-кнопки</a></li>
<li><a href="#callback-кнопки-и-редактирование-сообщений">Callback-кнопки и редактирование сообщений</a></li>
<li><a href="#switch-кнопки">Switch-кнопки</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
