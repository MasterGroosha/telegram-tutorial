<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 8. Bot API v2: Кнопки и редактирование сообщений
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css><meta property=og:title content="Пишем ботов для Telegram на языке Python"><meta property=og:image content=https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828><meta property=og:description content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_08\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 8. Bot API v2: Кнопки и редактирование сообщений</h1></header><article class=markdown><h2 id=введение>Введение</h2><p>В начале апреля 2016 года <a href=https://telegram.org/blog/bots-2-0>вышло</a> первое по-настоящему крупное обновление API для ботов. Изменений довольно много, поэтому материал я разобью на несколько частей. Сегодня поговорим об inline-кнопках и редактировании сообщений, а затем обсудим новые инлайн-режимы вместе со специальными кнопками для отправки геолокации и номера телефона.</p><h2 id=новые-возможности>Новые возможности</h2><p>Начнём с двух важных изменений:<br>1) Каждая кнопка, будь то обычная или инлайн, это теперь самостоятельный объект <code>KeyboardButton</code> или <code>InlineKeyboardButton</code>, не забудьте обновить своих ботов!<br>2) В Inline-режиме все текстовые поля теперь представлены отдельными объектами <code>InputMessageContent</code>, которые, в свою очередь могут быть аж 4-х типов (подробности <a href=https://core.telegram.org/bots/api#inputmessagecontent>тут</a>).</p><h3 id=url-кнопки>URL-кнопки</h3><p>Итак, <strong>инлайн-кнопки</strong>. Что это такое? Это специальные объекты, которые &ldquo;цепляются&rdquo; к конкретным сообщениям и распространяют своё действие, в общем случае, только на них. Делятся такие кнопки на три типа: URL-кнопки, Callback-кнопки и Switch-кнопки.
Самыми простыми являются кнопки-ссылки (URL). Как видно из названия, их цель - просто перекидывать пользователей по определенным веб-адресам. Давайте сразу напишем обработчик, который будет на любое сообщение отвечать каким-либо текстом и предложением перейти, например, на Яндекс.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>@bot.message_handler(content_types=[&#34;text&#34;])
def default_test(message):
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton(text=&#34;Перейти на Яндекс&#34;, url=&#34;https://ya.ru&#34;)
    keyboard.add(url_button)
    bot.send_message(message.chat.id, &#34;Привет! Нажми на кнопку и перейди в поисковик.&#34;, reply_markup=keyboard)</code></pre></div><p>Инлайн-клавиатура представляет собой объект <code>InlineKeyboardMarkup</code>, а каждая инлайн-кнопка – это объект <code>InlineKeyboardButton</code>. Чтобы получилась URL-кнопка, нужно указать значения параметров <code>text</code> (текст на кнопке) и <code>url</code> (валидный веб-адрес). В результате бот пришлет нам такое сообщение (см. рис.). В целях обеспечения безопасности, перед переходом по URL-кнопкам появляется всплывающее окно, в котором видна ссылка целиком.</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l8_1.png alt=URL-кнопка><figcaption><h4><i>URL-кнопка</i></h4></figcaption></figure></center></p><h3 id=callback-кнопки-и-редактирование-сообщений>Callback-кнопки и редактирование сообщений</h3><p>Прежде, чем мы перейдем к другим кнопкам, давайте познакомимся с функциями редактирования сообщений, коих тоже три: <code>editMessageText</code> (редактирование текста), <code>editMessageCaption</code> (редактирование подписи к медиа) и <code>editMessageReplyMarkup</code> (редактирование инлайн-клавиатуры). В рамках этого урока рассмотрим только первую функцию, остальные работают аналогично и предлагаются для самостоятельного изучения.<br>Чтобы отредактировать сообщение, нам надо знать, про какое именно идёт речь. В случае, если оно было отправлено самим ботом, идентификаторами служит связка <code>chat_id</code> + <code>message_id</code>. Но если сообщение было отправлено в инлайн-режиме, то ориентироваться надо по параметру <code>inline_message_id</code>.</p><p>И вот теперь вернемся к нашим <del>баранам</del> кнопкам. На очереди – <strong>Callback</strong>. Это, на мой взгляд, самая крутая фича нового обновления. Колбэк-кнопки позволяют выполнять произвольные действия по их нажатию. Всё зависит от того, какие параметры каждая кнопка в себе несёт. Соответственно, все нажатия будут приводить к отправке боту объекта <code>CallbackQuery</code>, содержащему поле <code>data</code>, в котором написана некоторая строка, заложенная в кнопку, а также либо объект <code>Message</code>, если сообщение отправлено ботом в обычном режиме, либо поле <code>inline_message_id</code>, если сообщение отправлено в инлайн-режиме.</p><p>Приведу пример, после которого все вопросы должны отпасть: пусть, например, если сообщение отправлено ботом в обычном режиме, то нажатие на кнопку заменит текст сообщения на &ldquo;Пыщь&rdquo;, если в инлайн – то &ldquo;Бдыщь&rdquo;. При этом в обоих случаях значение <code>callback_data</code> будет равно <code>test</code>. Что для этого нужно сделать: во-первых, написать простейший хэндлер для всех входящих сообщений, во-вторых, написать простейший хэндлер для инлайн-сообщений, в-третьих, написать простейший хэндлер для колбэка, который определит, из какого режима пришло сообщение.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># Обычный режим
@bot.message_handler(content_types=[&#34;text&#34;])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    callback_button = types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, callback_data=&#34;test&#34;)
    keyboard.add(callback_button)
    bot.send_message(message.chat.id, &#34;Я – сообщение из обычного режима&#34;, reply_markup=keyboard)


# Инлайн-режим с непустым запросом
@bot.inline_handler(lambda query: len(query.query) &gt; 0)
def query_text(query):
    kb = types.InlineKeyboardMarkup()
    # Добавляем колбэк-кнопку с содержимым &#34;test&#34;
    kb.add(types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, callback_data=&#34;test&#34;))
    results = []
    single_msg = types.InlineQueryResultArticle(
        id=&#34;1&#34;, title=&#34;Press me&#34;,
        input_message_content=types.InputTextMessageContent(message_text=&#34;Я – сообщение из инлайн-режима&#34;),
        reply_markup=kb
    )
    results.append(single_msg)
    bot.answer_inline_query(query.id, results)


# В большинстве случаев целесообразно разбить этот хэндлер на несколько маленьких
@bot.callback_query_handler(func=lambda call: True)
def callback_inline(call):
    # Если сообщение из чата с ботом
    if call.message:
        if call.data == &#34;test&#34;:
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=&#34;Пыщь&#34;)
    # Если сообщение из инлайн-режима
    elif call.inline_message_id:
        if call.data == &#34;test&#34;:
            bot.edit_message_text(inline_message_id=call.inline_message_id, text=&#34;Бдыщь&#34;)

if __name__ == &#39;__main__&#39;:
    bot.infinity_polling()</code></pre></div><p>Запускаем бота, отправляем инлайн-сообщение, которое, в свою очередь, вызовет обычное:</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l8_2.png alt><figcaption><h4><i></i></h4></figcaption></figure></center></p><p>Нажмем на обе кнопки, результат правильный:</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l8_3.png alt="После проверки"><figcaption><h4><i>После проверки</i></h4></figcaption></figure></center></p><p>Таким образом, callback-кнопки – это очень мощный инструмент для взаимодействия пользователей с ботом, а редактирование сообщений дополнительно помогает в этом.
Более того, нажатие на колбэк-кнопку может дополнительно тригернуть либо уведомление в верхней части экрана, либо всплывающее окно. Покажу первый вариант. Пускай помимо изменения сообщения на &ldquo;Пыщь&rdquo;, аналогичное слово показывается уведомлением. Для этого перепишем первое if-условие в хендлере колбэков:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>if call.message:
    if call.data == &#34;test&#34;:
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=&#34;Пыщь&#34;)
        bot.answer_callback_query(callback_query_id=call.id, show_alert=False, text=&#34;Пыщь!&#34;)</code></pre></div><p>Результат – на скриншоте. Попробуйте, кстати, изменить аргумент <code>show_alert</code> на <code>True</code> и посмотрите, что получится.</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l8_4.png alt="Всплывающее уведомление"><figcaption><h4><i>Всплывающее уведомление</i></h4></figcaption></figure></center></p><h3 id=switch-кнопки>Switch-кнопки</h3><p>Наконец, остался последний тип кнопок - <strong>Switch</strong> (переключатель). Они нужны, чаще всего, для обучения пользователей работе с ботом в инлайн-режиме. Чтобы активировать сделать кнопку такого типа, нужно указать аргумент <code>switch_inline_query</code> либо пустой, либо с каким-либо текстом. В последнем случае этот текст будет сразу подставлен в поле ввода, например, для показа демонстрации инлайна. Как вообще работает такая кнопка? При нажатии на неё Telegram предложит выбрать чат, после чего подставит в поле ввода ник вашего бота и (если есть), текст, указанный вами в аргументе <code>switch_inline_query</code>. Давайте попробуем так сделать. Добавим кнопку, которая будет перенаправлять пользователя в какой-либо чат и предлагать в инлайн-режиме запрос &ldquo;Telegram&rdquo;. Код всего хендлера выглядит вот так:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>@bot.message_handler(content_types=[&#34;text&#34;])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    switch_button = types.InlineKeyboardButton(text=&#34;Нажми меня&#34;, switch_inline_query=&#34;Telegram&#34;)
    keyboard.add(switch_button)
    bot.send_message(message.chat.id, &#34;Я – сообщение из обычного режима&#34;, reply_markup=keyboard)</code></pre></div><p>Теперь, если мы нажмем на кнопку и выберем чат, вот что получится:</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l8_5.png alt=Результат><figcaption><h4><i>Результат</i></h4></figcaption></figure></center></p><p>Итак, в этом уроке мы познакомились с новыми кнопками в Telegram Bot API, научились <del>переписывать историю</del> редактировать сообщения и отправлять небольшие уведомления по нажатию. В следующий раз продолжим изучать новые возможности для ботов.
А исходники к этому уроку можно найти в <a href=https://github.com/MasterGroosha/telegram-tutorial>этом репозитории</a></p><p><a href=/telegram-tutorial/docs/lesson_07/ class=book-btn style=float:left>← Урок №7</a>
<a href=/telegram-tutorial/docs/lesson_09/ class=book-btn style=float:right>Урок №9 →</a></p></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><ul><li><a href=#введение>Введение</a></li><li><a href=#новые-возможности>Новые возможности</a><ul><li><a href=#url-кнопки>URL-кнопки</a></li><li><a href=#callback-кнопки-и-редактирование-сообщений>Callback-кнопки и редактирование сообщений</a></li><li><a href=#switch-кнопки>Switch-кнопки</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>