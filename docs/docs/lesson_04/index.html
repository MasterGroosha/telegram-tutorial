<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 4. Вебхуки
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css><meta property=og:title content="Пишем ботов для Telegram на языке Python"><meta property=og:image content=https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828><meta property=og:description content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_04\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 4. Вебхуки</h1></header><article class=markdown><p>⁠</p><p>С простым ботом наконец-то разобрались, теперь будем осваивать различные &ldquo;плюшки&rdquo;. Первая из них и, пожалуй, самая главная, — вебхуки.</p><h2 id=а-в-чём-собственно-разница>А в чём, собственно, разница?</h2><p><em>(Следующий абзац был написан в 2015-2016г., библиотеки с того момента много обновлялись, поэтому в некоторых случаях использовать Long Polling будет не хуже, чем вебхуки)</em>.<br>Давайте для начала разберемся, как боты принимают сообщения. Первый и наиболее простой вариант заключается в периодическом опросе серверов Telegram на предмет наличия новой информации. Всё это осуществляется через т.н. <a href=https://en.wikipedia.org/wiki/Push_technology#Long_polling>Long Polling</a>, т.е. открывается соединение на непродолжительное время и все обновления тут же прилетают боту. Просто, но не очень надежно. Во-первых, серверы Telegram периодически начинают возвращать <a href=https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP#504>ошибку 504</a> (Gateway Timeout), из-за чего некоторые боты впадают в ступор. Даже pyTelegramBotAPI, используемый мной, не всегда может пережить такое.
Во-вторых, если одновременно запущено несколько ботов, вероятность столкнуться с ошибками возрастает. Это вдвойне обидно, если сами боты используются не очень часто.</p><p>Вебхуки работают несколько иначе. Устанавливая вебхук, вы как бы говорите серверам Telegram: &ldquo;Слышь, если кто мне напишет, стукни сюда — (ссылка)&rdquo;. Отпадает необходимость периодически самому опрашивать серверы, тем самым, исчезает неприятная причина падений ботов. Однако за это приходится платить необходимостью установки полноценного веб-сервера на ту машину, на которой планируется запускать ботов. Что ещё неприятно, надо иметь собственный SSL-сертификат, т.к. вебхуки в телеграме работают только по <a href=https://ru.wikipedia.org/wiki/HTTPS>HTTPS</a>. К счастью, в один прекрасный день появилась поддержка p<a href=https://ru.wikipedia.org/wiki/Самозаверенный_сертификат>самоподписанных сертификатов</a>. Вот об их применении я и расскажу.</p><h2 id=создаем-сертификат>Создаем сертификат</h2><p>Повторюсь: я не считаю себя супер-мега-крутым специалистом в айти, возможно, я что-то делаю неправильно, тем не менее, это работает и выглядит вполне прилично. Ладно, приступим.<br>Для начала, установим пакет openssl (для Linux):<br><code>sudo apt-get install openssl</code><br>Затем сгенерируем приватный ключ:<br><code>openssl genrsa -out webhook_pkey.pem 2048</code><br>Теперь, внимание, генерируем самоподписанный сертификат вот этой вот длинной командой:<br><code>openssl req -new -x509 -days 3650 -key webhook_pkey.pem -out webhook_cert.pem</code><br>Нам предложат ввести некоторую информацию о себе: двухбуквенный код страны, имя организации и т.д. Если не хотите ничего вводить, ставьте точку. <strong>НО! ВАЖНО!</strong> Когда дойдете до предложения ввести Common Name, следует написать IP адрес сервера, на котором будет запущен бот.</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l4_1.jpg alt="Генерация сертификата"><figcaption><h4><i>Генерация сертификата</i></h4></figcaption></figure></center></p><p>В результате получим файлы <code>webhook_cert.pem</code> и <code>webhook_pkey.pem</code>, положим их в какой-нибудь пустой каталог, в котором потом будем создавать бота. Сертификаты готовы, теперь займемся ботом. Чтобы не сильно загружать себе мозги, напишем простого echo-bot&rsquo;а из <a href=/telegram-tutorial/docs/lesson_01/>урока №1</a>, только теперь с использованием сертификата.</p><h2 id=наш-вишнёвый-сервер>Наш вишнёвый сервер</h2><p>Выше я упомянул необходимость наличия веб-сервера, для работы с вебхуками. Те, кто умело владеет Apache или Nginx, можете дальше не читать. Лично я никак не мог (и не могу до сих пор) понять, как обрабатывать входящие сообщения от этих серверов в Python. Поэтому, было принято простое и довольно эффективное решение - используем веб-фреймворк <a href=http://www.cherrypy.org/>CherryPy</a>. Это не самый простой фреймворк по сравнению, например, с <a href=http://flask.pocoo.org/>Flask</a>, но мы будем использовать именно его.<br>Итак, установим CherryPy простой командой <code>python3 -m pip install cherrypy</code></p><h2 id=новый-старый-бот>Новый старый бот</h2><p>Перейдем в каталог с нашими сертификатами и создадим файлы <code>bot.py</code> и <code>config.py</code>. В последнем создадим переменную <code>token</code>, в которую передадим токен нашего бота. Открываем <code>bot.py</code>.<br>Импортируем 2 библиотеки, зададим необходимые константы и создадим экземпляр бота:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>#!/usr/bin/env/python3
# -*- coding: utf-8 -*-
import telebot
import cherrypy
import config

WEBHOOK_HOST = &#39;IP-адрес сервера, на котором запущен бот&#39;
WEBHOOK_PORT = 443  # 443, 80, 88 или 8443 (порт должен быть открыт!)
WEBHOOK_LISTEN = &#39;0.0.0.0&#39;  # На некоторых серверах придется указывать такой же IP, что и выше

WEBHOOK_SSL_CERT = &#39;./webhook_cert.pem&#39;  # Путь к сертификату
WEBHOOK_SSL_PRIV = &#39;./webhook_pkey.pem&#39;  # Путь к приватному ключу

WEBHOOK_URL_BASE = &#34;https://%s:%s&#34; % (WEBHOOK_HOST, WEBHOOK_PORT)
WEBHOOK_URL_PATH = &#34;/%s/&#34; % (config.token)

bot = telebot.TeleBot(config.token)</code></pre></div><p><strong>Обратите внимание</strong>, что Telegram поддерживает всего 4 различных порта при работе с самоподписанными сертификатами. Теоретически, это означает, что на одной машине может быть запущено не больше 4 ботов на вебхуках. Практически, это поправимо, но об этом - в следующий раз.</p><p>Создадим класс, реализующий экземпляр веб-сервера. Это, в принципе, стандартный код, который от бота к боту сильно меняться не будет:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># Наш вебхук-сервер
class WebhookServer(object):
    @cherrypy.expose
    def index(self):
        if &#39;content-length&#39; in cherrypy.request.headers and \
                        &#39;content-type&#39; in cherrypy.request.headers and \
                        cherrypy.request.headers[&#39;content-type&#39;] == &#39;application/json&#39;:
            length = int(cherrypy.request.headers[&#39;content-length&#39;])
            json_string = cherrypy.request.body.read(length).decode(&#34;utf-8&#34;)
            update = telebot.types.Update.de_json(json_string)
            # Эта функция обеспечивает проверку входящего сообщения
            bot.process_new_updates([update])
            return &#39;&#39;
        else:
            raise cherrypy.HTTPError(403)</code></pre></div><p>Посмотрите на название функции: <code>index</code>. Это, по сути, обозначает последнюю часть URL. Поясню на примере: если бы мы хотели получать обновления на адрес <code>80.100.95.20/webhooksbot</code>, то функцию выше мы бы назвали <code>webhooksbot</code>. index - это аналог отсутствия какой-либо дополнительной маршрутизации. Зачем менять это значение на другое, рассказано <a href=/telegram-tutorial/docs/lesson_12/>здесь</a>, сейчас это не нужно.<br>Итак, что мы видим в коде выше? Принимаем входящие запросы по URL <code>наш.ip.адрес/</code>, получаем содержимое и прогоняем через набор хэндлеров. Кстати, о них. Т.к. мы реализуем простейших echo-бот, хэндлер нам нужен всего один:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># Хэндлер на все текстовые сообщения
@bot.message_handler(func=lambda message: True, content_types=[&#39;text&#39;])
def echo_message(message):
    bot.reply_to(message, message.text)</code></pre></div><p>Внимательный читатель всё же заметит одно отличие, о котором я говорить не буду ;) Заодно ещё один повод открыть документацию.</p><p>Далее, отправим серверу наш самоподписанный сертификат и &ldquo;обратный адрес&rdquo;, по которому просим сообщать обо всех новых сообщениях:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># Снимаем вебхук перед повторной установкой (избавляет от некоторых проблем)
bot.remove_webhook()

 # Ставим заново вебхук
bot.set_webhook(url=WEBHOOK_URL_BASE + WEBHOOK_URL_PATH,
                certificate=open(WEBHOOK_SSL_CERT, &#39;r&#39;))</code></pre></div><p>Наконец, укажем настройки нашего сервера и запустим его!</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># Указываем настройки сервера CherryPy
cherrypy.config.update({
    &#39;server.socket_host&#39;: WEBHOOK_LISTEN,
    &#39;server.socket_port&#39;: WEBHOOK_PORT,
    &#39;server.ssl_module&#39;: &#39;builtin&#39;,
    &#39;server.ssl_certificate&#39;: WEBHOOK_SSL_CERT,
    &#39;server.ssl_private_key&#39;: WEBHOOK_SSL_PRIV
})

 # Собственно, запуск!
cherrypy.quickstart(WebhookServer(), WEBHOOK_URL_PATH, {&#39;/&#39;: {}})</code></pre></div><p>Обратите внимание на последнюю строку. Наш сервер в качестве &ldquo;корня&rdquo; будет прослушивать адрес вида &ldquo;ip-адрес/токен_бота&rdquo;, относительно которого index - это и есть этот адрес. Может, немного криво пояснил, но позднее вам всё станет предельно ясно, сейчас не нужно загромождать голову лишней информацией.</p><p>Запустим бота и напишем ему парочку сообщений. Затем посмотрим в окно терминала:</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l4_2.jpg alt="Лог сервера"><figcaption><h4><i>Лог сервера</i></h4></figcaption></figure></center></p><p>Если код статуса равен <a href=https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP#200>200 (OK)</a>, значит, всё в порядке и бот получил сообщения от сервера.</p><p>На сегодня всё.</p><p><a href=/telegram-tutorial/docs/lesson_03/ class=book-btn style=float:left>← Урок №3</a>
<a href=/telegram-tutorial/docs/lesson_05/ class=book-btn style=float:right>Урок №5 →</a></p></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><ul><li><a href=#а-в-чём-собственно-разница>А в чём, собственно, разница?</a></li><li><a href=#создаем-сертификат>Создаем сертификат</a></li><li><a href=#наш-вишнёвый-сервер>Наш вишнёвый сервер</a></li><li><a href=#новый-старый-бот>Новый старый бот</a></li></ul></li></ul></nav></aside></main></body></html>