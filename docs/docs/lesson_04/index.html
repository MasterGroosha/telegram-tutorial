<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Урок 4. Вебхуки
  
 | Пишем ботов для Telegram на языке Python</title>



<link rel="stylesheet" href="/test-web/css/override.css">
<link rel="stylesheet" href="/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css">

<meta property="og:title" content="Пишем ботов для Telegram на языке Python" />
<meta property="og:image" content="https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828" />
<meta property="og:description" content="Учебник для ботописателей" />



<link rel="icon" href="/telegram-tutorial/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://mastergroosha.github.io/telegram-tutorial/">Пишем ботов для Telegram на языке Python</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2ftelegram-tutorial\2f docs\2flesson_04\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li><a href="/telegram-tutorial/docs/lesson_01/">Урок 1. Введение, простой echo-бот</a></li>
<li><a href="/telegram-tutorial/docs/lesson_02/">Урок 2. “Угадай мелодию”. Подготовка</a></li>
<li><a href="/telegram-tutorial/docs/lesson_03/">Урок 3. “Угадай мелодию”. Завершаем бота</a></li>
<li><a href="/telegram-tutorial/docs/lesson_04/">Урок 4. Вебхуки</a></li>
<li><a href="/telegram-tutorial/docs/lesson_05/">Урок 5. Автопостинг в каналы</a></li>
<li><a href="/telegram-tutorial/docs/lesson_06/">Урок 6. Собираем аналитику при помощи Botan</a></li>
<li><a href="/telegram-tutorial/docs/lesson_07/">Урок 7. Встраиваемые боты (Inline)</a></li>
<li><a href="/telegram-tutorial/docs/lesson_08/">Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li>
<li><a href="/telegram-tutorial/docs/lesson_09/">Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li>
<li><a href="/telegram-tutorial/docs/lesson_10/">Урок 10. Bot API v3. Автоматизируем работу в группах</a></li>
<li><a href="/telegram-tutorial/docs/lesson_11/">Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li>
<li><a href="/telegram-tutorial/docs/lesson_12/">Урок 12. Запускаем несколько ботов на одном сервере</a></li>
</ul>





</nav>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="/telegram-tutorial/svg/menu.svg" alt="Menu" />
  </label>
</header>

      
<header class="markdown">
  <h1>Урок 4. Вебхуки</h1>
</header>
<article class="markdown">

<p>⁠</p>

<p>С простым ботом наконец-то разобрались, теперь будем осваивать различные &ldquo;плюшки&rdquo;. Первая из них и, пожалуй, самая главная, — вебхуки.</p>

<h2 id="а-в-чём-собственно-разница">А в чём, собственно, разница?</h2>

<p><em>(Следующий абзац был написан в 2015-2016г., библиотеки с того момента много обновлялись, поэтому в некоторых случаях использовать Long Polling будет не хуже, чем вебхуки)</em>.<br />
Давайте для начала разберемся, как боты принимают сообщения. Первый и наиболее простой вариант заключается в периодическом опросе серверов Telegram на предмет наличия новой информации. Всё это осуществляется через т.н. <a href="https://en.wikipedia.org/wiki/Push_technology#Long_polling">Long Polling</a>, т.е. открывается соединение на непродолжительное время и все обновления тут же прилетают боту. Просто, но не очень надежно. Во-первых, серверы Telegram периодически начинают возвращать <a href="https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP#504">ошибку 504</a> (Gateway Timeout), из-за чего некоторые боты впадают в ступор. Даже pyTelegramBotAPI, используемый мной, не всегда может пережить такое.
Во-вторых, если одновременно запущено несколько ботов, вероятность столкнуться с ошибками возрастает. Это вдвойне обидно, если сами боты используются не очень часто.</p>

<p>Вебхуки работают несколько иначе. Устанавливая вебхук, вы как бы говорите серверам Telegram: &ldquo;Слышь, если кто мне напишет, стукни сюда — (ссылка)&rdquo;. Отпадает необходимость периодически самому опрашивать серверы, тем самым, исчезает неприятная причина падений ботов. Однако за это приходится платить необходимостью установки полноценного веб-сервера на ту машину, на которой планируется запускать ботов. Что ещё неприятно, надо иметь собственный SSL-сертификат, т.к. вебхуки в телеграме работают только по <a href="https://ru.wikipedia.org/wiki/HTTPS">HTTPS</a>. К счастью, в один прекрасный день появилась поддержка p<a href="https://ru.wikipedia.org/wiki/Самозаверенный_сертификат">самоподписанных сертификатов</a>. Вот об их применении я и расскажу.</p>

<h2 id="создаем-сертификат">Создаем сертификат</h2>

<p>Повторюсь: я не считаю себя супер-мега-крутым специалистом в айти, возможно, я что-то делаю неправильно, тем не менее, это работает и выглядит вполне прилично. Ладно, приступим.<br />
Для начала, установим пакет openssl (для Linux):<br />
<code>sudo apt-get install openssl</code><br />
Затем сгенерируем приватный ключ:<br />
<code>openssl genrsa -out webhook_pkey.pem 2048</code><br />
Теперь, внимание, генерируем самоподписанный сертификат вот этой вот длинной командой:<br />
<code>openssl req -new -x509 -days 3650 -key webhook_pkey.pem -out webhook_cert.pem</code><br />
Нам предложат ввести некоторую информацию о себе: двухбуквенный код страны, имя организации и т.д. Если не хотите ничего вводить, ставьте точку. <strong>НО! ВАЖНО!</strong> Когда дойдете до предложения ввести Common Name, следует написать IP адрес сервера, на котором будет запущен бот.</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l4_1.jpg" alt="Генерация сертификата"/>
    <figcaption>
         <h4><i>Генерация сертификата</i></h4>
    </figcaption>
</figure>
</center></p>

<p>В результате получим файлы <code>webhook_cert.pem</code> и <code>webhook_pkey.pem</code>, положим их в какой-нибудь пустой каталог, в котором потом будем создавать бота. Сертификаты готовы, теперь займемся ботом. Чтобы не сильно загружать себе мозги, напишем простого echo-bot&rsquo;а из <a href="/telegram-tutorial/docs/lesson_01/">урока №1</a>, только теперь с использованием сертификата.</p>

<h2 id="наш-вишнёвый-сервер">Наш вишнёвый сервер</h2>

<p>Выше я упомянул необходимость наличия веб-сервера, для работы с вебхуками. Те, кто умело владеет Apache или Nginx, можете дальше не читать. Лично я никак не мог (и не могу до сих пор) понять, как обрабатывать входящие сообщения от этих серверов в Python. Поэтому, было принято простое и довольно эффективное решение - используем веб-фреймворк <a href="http://www.cherrypy.org/">CherryPy</a>. Это не самый простой фреймворк по сравнению, например, с <a href="http://flask.pocoo.org/">Flask</a>, но мы будем использовать именно его.<br />
Итак, установим CherryPy простой командой <code>python3 -m pip install cherrypy</code></p>

<h2 id="новый-старый-бот">Новый старый бот</h2>

<p>Перейдем в каталог с нашими сертификатами и создадим файлы <code>bot.py</code> и <code>config.py</code>. В последнем создадим переменную <code>token</code>, в которую передадим токен нашего бота. Открываем <code>bot.py</code>.<br />
Импортируем 2 библиотеки, зададим необходимые константы и создадим экземпляр бота:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none">#!/usr/bin/env/python3
# -*- coding: utf-8 -*-
import telebot
import cherrypy
import config

WEBHOOK_HOST = &#39;IP-адрес сервера, на котором запущен бот&#39;
WEBHOOK_PORT = 443  # 443, 80, 88 или 8443 (порт должен быть открыт!)
WEBHOOK_LISTEN = &#39;0.0.0.0&#39;  # На некоторых серверах придется указывать такой же IP, что и выше

WEBHOOK_SSL_CERT = &#39;./webhook_cert.pem&#39;  # Путь к сертификату
WEBHOOK_SSL_PRIV = &#39;./webhook_pkey.pem&#39;  # Путь к приватному ключу

WEBHOOK_URL_BASE = &#34;https://%s:%s&#34; % (WEBHOOK_HOST, WEBHOOK_PORT)
WEBHOOK_URL_PATH = &#34;/%s/&#34; % (config.token)

bot = telebot.TeleBot(config.token)</code></pre></div>

<p><strong>Обратите внимание</strong>, что Telegram поддерживает всего 4 различных порта при работе с самоподписанными сертификатами. Теоретически, это означает, что на одной машине может быть запущено не больше 4 ботов на вебхуках. Практически, это поправимо, но об этом - в следующий раз.</p>

<p>Создадим класс, реализующий экземпляр веб-сервера. Это, в принципе, стандартный код, который от бота к боту сильно меняться не будет:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none"># Наш вебхук-сервер
class WebhookServer(object):
    @cherrypy.expose
    def index(self):
        if &#39;content-length&#39; in cherrypy.request.headers and \
                        &#39;content-type&#39; in cherrypy.request.headers and \
                        cherrypy.request.headers[&#39;content-type&#39;] == &#39;application/json&#39;:
            length = int(cherrypy.request.headers[&#39;content-length&#39;])
            json_string = cherrypy.request.body.read(length).decode(&#34;utf-8&#34;)
            update = telebot.types.Update.de_json(json_string)
            # Эта функция обеспечивает проверку входящего сообщения
            bot.process_new_updates([update])
            return &#39;&#39;
        else:
            raise cherrypy.HTTPError(403)</code></pre></div>

<p>Посмотрите на название функции: <code>index</code>. Это, по сути, обозначает последнюю часть URL. Поясню на примере: если бы мы хотели получать обновления на адрес <code>80.100.95.20/webhooksbot</code>, то функцию выше мы бы назвали <code>webhooksbot</code>. index - это аналог отсутствия какой-либо дополнительной маршрутизации. Зачем менять это значение на другое, рассказано <a href="/telegram-tutorial/docs/lesson_12/">здесь</a>, сейчас это не нужно.<br />
Итак, что мы видим в коде выше? Принимаем входящие запросы по URL <code>наш.ip.адрес/</code>, получаем содержимое и прогоняем через набор хэндлеров. Кстати, о них. Т.к. мы реализуем простейших echo-бот, хэндлер нам нужен всего один:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none"># Хэндлер на все текстовые сообщения
@bot.message_handler(func=lambda message: True, content_types=[&#39;text&#39;])
def echo_message(message):
    bot.reply_to(message, message.text)</code></pre></div>

<p>Внимательный читатель всё же заметит одно отличие, о котором я говорить не буду ;) Заодно ещё один повод открыть документацию.</p>

<p>Далее, отправим серверу наш самоподписанный сертификат и &ldquo;обратный адрес&rdquo;, по которому просим сообщать обо всех новых сообщениях:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none"># Снимаем вебхук перед повторной установкой (избавляет от некоторых проблем)
bot.remove_webhook()

 # Ставим заново вебхук
bot.set_webhook(url=WEBHOOK_URL_BASE + WEBHOOK_URL_PATH,
                certificate=open(WEBHOOK_SSL_CERT, &#39;r&#39;))</code></pre></div>

<p>Наконец, укажем настройки нашего сервера и запустим его!</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-none" data-lang="none"># Указываем настройки сервера CherryPy
cherrypy.config.update({
    &#39;server.socket_host&#39;: WEBHOOK_LISTEN,
    &#39;server.socket_port&#39;: WEBHOOK_PORT,
    &#39;server.ssl_module&#39;: &#39;builtin&#39;,
    &#39;server.ssl_certificate&#39;: WEBHOOK_SSL_CERT,
    &#39;server.ssl_private_key&#39;: WEBHOOK_SSL_PRIV
})

 # Собственно, запуск!
cherrypy.quickstart(WebhookServer(), WEBHOOK_URL_PATH, {&#39;/&#39;: {}})</code></pre></div>

<p>Обратите внимание на последнюю строку. Наш сервер в качестве &ldquo;корня&rdquo; будет прослушивать адрес вида &ldquo;ip-адрес/токен_бота&rdquo;, относительно которого index - это и есть этот адрес. Может, немного криво пояснил, но позднее вам всё станет предельно ясно, сейчас не нужно загромождать голову лишней информацией.</p>

<p>Запустим бота и напишем ему парочку сообщений. Затем посмотрим в окно терминала:</p>

<p><center>
<figure style="padding: 0.25rem; margin: 1rem 0">
    <img style="max-width: 100%; height: auto;" src="/test-web/images/l4_2.jpg" alt="Лог сервера"/>
    <figcaption>
         <h4><i>Лог сервера</i></h4>
    </figcaption>
</figure>
</center></p>

<p>Если код статуса равен <a href="https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP#200">200 (OK)</a>, значит, всё в порядке и бот получил сообщения от сервера.</p>

<p>На сегодня всё.</p>

<p>



  

<a  href="/telegram-tutorial/docs/lesson_03/"   class="book-btn" style="float: left;">← Урок №3</a>





  

<a  href="/telegram-tutorial/docs/lesson_05/"   class="book-btn" style="float: right;">Урок №5 →</a>
</p>
</article>

      

      
    </div>

    
  

  <aside class="book-toc level-3 fixed">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#а-в-чём-собственно-разница">А в чём, собственно, разница?</a></li>
<li><a href="#создаем-сертификат">Создаем сертификат</a></li>
<li><a href="#наш-вишнёвый-сервер">Наш вишнёвый сервер</a></li>
<li><a href="#новый-старый-бот">Новый старый бот</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
