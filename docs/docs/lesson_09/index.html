<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7d5ee4f671b06dde5fd61ab409a54048ba7759e99fed39ac32a7be45d4d92cd.css><meta property=og:title content="Пишем ботов для Telegram на языке Python"><meta property=og:image content=https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828><meta property=og:description content="Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_09\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li><li><a href=/telegram-tutorial/docs/lesson_13/>Урок 13. Опросы v2.0</a></li><li><a href=/telegram-tutorial/docs/lesson_14/>Урок 14. Конечные автоматы в aiogram, разбиваем логику по файлам</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</h1></header><article class=markdown><p>⁠</p><p><a href=/telegram-tutorial/docs/lesson_08/>Продолжаю</a> рассказывать о нововведениях в Bot API версии 2. Мы не будем рассматривать методы <a href=https://core.telegram.org/bots/api#getchat>getChat</a>, <a href=https://core.telegram.org/bots/api#getchatmember>getChatMember</a> и т.д., которые <a href=https://core.telegram.org/bots/api#recent-changes>появились</a> в обновлении 2.1: они интуитивно понятны и особых проблем не вызывают. Вопросы могут возникнуть при изучении специальных обычных кнопок, вроде тех, что запрашивают у вас номер телефона и геолокацию, при попытке получить отредактированное сообщение, а также при работе с уже загруженными в облако объектами с инлайн-режимом. Обо всём по порядку.</p><h2 id=специальные-кнопки>Специальные кнопки</h2><p>Некоторым ботам жизненно необходим ваш номер телефона или местоположение, например, для привязки к учётным записям на других сайтах или же поиска близлежащих объектов на карте. Разработчики Telegram прислушались к мнению ботоводов и добавили особые свойства обычным (не инлайновым) кнопкам. Итак, чтобы запросить номер телефона, нужно помимо аргумента <code>text</code> передать аргумент <code>request_contact=True</code>, а для геолокации, соответственно, <code>request_location=True</code>. Обратите внимание, что одновременно у кнопки может быть не больше одного особого свойства (можно не указывать никакой), а также что специальные кнопки могут быть отправлены только в диалоги (бот-человек). Напишем код, который на команду <strong>/geophone</strong> отправит нам клавиатуру с этими кнопками.</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l9_1.jpg alt="Нажатие на кнопку запроса телефона"><figcaption><h4><i>Нажатие на кнопку запроса телефона</i></h4></figcaption></figure></center></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none># не забудьте про from telebot import types
@bot.message_handler(commands=[&#34;geophone&#34;])
def geophone(message):
    # Эти параметры для клавиатуры необязательны, просто для удобства
    keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    button_phone = types.KeyboardButton(text=&#34;Отправить номер телефона&#34;, request_contact=True)
    button_geo = types.KeyboardButton(text=&#34;Отправить местоположение&#34;, request_location=True)
    keyboard.add(button_phone, button_geo)
    bot.send_message(message.chat.id, &#34;Отправь мне свой номер телефона или поделись местоположением, жалкий человечишка!&#34;, reply_markup=keyboard)</code></pre></div><p>При нажатии на кнопку отправки номера телефона сервер вернёт объект Message с непустым типом <a href=https://core.telegram.org/bots/api#contact>Contact</a>, а при нажатии на кнопку отправки геолокации – с непустым типом <a href=https://core.telegram.org/bots/api#location>Location</a>.</p><p><strong>Важно</strong>: если вы используете <a href=/telegram-tutorial/docs/lesson_11/>конечные автоматы</a> или любой другой механизм состояний, который будет ждать от пользователя его телефон в объекте Contact, помните, что ушлый юзер может попробовать обмануть бота и скинуть любой другой контакт из записной книжки. Чтобы убедиться, что номер телефона принадлежит именно этому конкретному пользователю, сравните <code>user_id</code> в объекте <code>from</code> с <code>user_id</code> в объекте <code>Contact</code>, они должны совпадать.</p><h2 id=редактирование-сообщений-пользователями>Редактирование сообщений пользователями</h2><p>Начиная с <a href=https://telegram.org/blog/edit>мая 2016 года</a>, пользователи могут редактировать свои сообщения, а боты могут видеть исправления. Как им в этом помочь, давайте разберёмся вместе. В качестве примера заставим нашего бота отвечать на ругательства. К примеру, если пользователь пишет &ldquo;дурак&rdquo;, бот ответит &ldquo;сам дурак&rdquo;. Хитрые люди могут попробовать отредактировать своё сообщение и выставить бота в дурном свете, но мы будем изменять ответ бота под пользовательский текст.</p><p>Для отслеживания изменений, у нас в копилке появился новый тип хэндлеров – <code>edited_message_handler</code>, который настраивается точно так же, как и <code>message_handler</code>, просто &ldquo;ловит&rdquo; он только те сообщения, которые отредактированы. Что ж, ничего сложного, пишем!</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>@bot.message_handler(func=lambda message: True)
def any_message(message):
    bot.reply_to(message, &#34;Сам {!s}&#34;.format(message.text))


@bot.edited_message_handler(func=lambda message: True)
def edit_message(message):
    bot.edit_message_text(chat_id=message.chat.id,
                          text= &#34;Сам {!s}&#34;.format(message.text),
                          message_id=message.message_id + 1)</code></pre></div><p>Заметили? Да, при вызове <code>edit_message_text</code> надо указать <code>message_id</code> на единицу бОльший, чем тот, который прислан сервером, потому что сервер сообщает о сообщении от пользователя, а нам нужно редактировать сообщение бота, которое шло за ним следом. И вот как это будет выглядеть (это одни и те же сообщения, что видно по метке &ldquo;изм.&rdquo; около моего)</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l9_2.png alt="Обмен любезностями"><figcaption><h4><i>Обмен любезностями</i></h4></figcaption></figure></center></p><h2 id=кэшированный-инлайн>Кэшированный инлайн</h2><p>Когда <a href=https://core.telegram.org/bots/inline>инлайн-боты</a> только появились, то в качестве источника данных для ответов надо было указывать внешние ссылки, причем с ограничениями по размеру указываемого файла. Очевидно, такой подход мог быть не очень быстрым, а чем дольше пользователь ждёт, тем он менее доволен результатами работы бота :) В итоге, в Bot API v2 инлайн-режиму разрешили в качестве источника для медиа использовать <code>file_id</code> уже имеющихся на сервере файлов (<em>напомню, что <code>file_id</code> для одного и того же файла будут разниться от бота к боту</em>) Итак, у меня есть <code>file_id</code> двух фотографий с <a href=https://ru.wikipedia.org/wiki/Капибара>капибарами</a> (как получить <code>file_id</code> загружаемых боту фотографий, считайте это заданием для самоподготовки), надо на любой инлайн-запрос (даже пустой) предложить эти 2 изображения. По сути, всё сводится к замене типа <code>InlineQueryResultPhoto</code> на тип <code>InlineQueryResultCachedPhoto</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-none data-lang=none>@bot.inline_handler(func=lambda query: True)
def inline_mode(query):
    capibara1 = types.InlineQueryResultCachedPhoto(
        id=&#34;1&#34;,
        photo_file_id=&#34;AgADAgAD6rMxGyBnGwABgBmcoHgy01IENAAQSYK_1gyoAAU-5aQACAg&#34;,
        caption=&#34;Это капибара №1&#34;
    )
    capibara2 = types.InlineQueryResultCachedPhoto(
        id=&#34;2&#34;,
        photo_file_id=&#34;AgADAgAD67MxGyBnGwABCvqPIYxMoNHENAAS51HjO88y_Z0ffAQABAg&#34;,
        caption=&#34;Это капибара №2&#34;
    )
    bot.answer_inline_query(query.id, [capibara1, capibara2])</code></pre></div><p>Запускаем бота. Ура, теперь мы умеем очень быстро предлагать разных капибар нашим пользователям :)</p><p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/telegram-tutorial/images/l9_3.png alt="Каталог капибар? о_О"><figcaption><h4><i>Каталог капибар? о_О</i></h4></figcaption></figure></center></p><p>Помимо фотографий, из &ldquo;кэша&rdquo; можно показывать любые типы, поддерживаемые мессенджером: видео, аудио, стикеры, файлы (пока что только <code>pdf</code> и <code>zip</code>).</p><p>На этом всё. <strong>Хороших ботов</strong>!</p><p><a href=/telegram-tutorial/docs/lesson_08/ class=book-btn style=float:left>← Урок №8</a>
<a href=/telegram-tutorial/docs/lesson_10/ class=book-btn style=float:right>Урок №10 →</a></p></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><ul><li><a href=#специальные-кнопки>Специальные кнопки</a></li><li><a href=#редактирование-сообщений-пользователями>Редактирование сообщений пользователями</a></li><li><a href=#кэшированный-инлайн>Кэшированный инлайн</a></li></ul></li></ul></nav></aside></main></body></html>